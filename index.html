<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/>
<title>HoverRush by ATFCars</title>
<style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      overflow: hidden;
      touch-action: none;
      font-family: 'Courier New', Courier, monospace;
      color: white;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
       -webkit-tap-highlight-color: transparent;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    #gameCanvas {
      background: #050510;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
      cursor: none;
    }

    #start-screen {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(10, 10, 20, 0.85);
      z-index: 10;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
      border: 3px solid #0ff;
      box-shadow: 0 0 15px #0ff;
      overflow-y: auto;
      max-height: 100vh;
    }

    #start-screen h1 {
      font-size: clamp(1.8em, 5vw, 2.5em);
      color: #ff0;
      text-shadow: 2px 2px #f0f;
      margin-top: 10px;
      margin-bottom: 10px;
    }

    #start-screen p {
      font-size: clamp(0.9em, 3vw, 1.1em);
      margin: 8px 0;
      line-height: 1.3;
    }

    #start-screen p.tagline {
      font-style: italic;
      max-width: 500px;
      margin: 10px auto 8px auto;
    }

    #start-instructions {
        margin-top: 10px;
        margin-bottom: 10px;
        border: 1px solid #555;
        padding: 8px 12px;
        border-radius: 5px;
        background-color: rgba(0,0,0,0.2);
        max-width: 90%;
        box-sizing: border-box;
        font-size: clamp(0.75em, 2.2vw, 0.9em);
        color: #ccc;
    }
    #start-instructions h3 {
        margin: 8px 0 4px 0;
        font-size: clamp(1em, 3vw, 1.1em);
        color: #0ff;
        text-transform: uppercase;
        letter-spacing: 1px;
        text-align: left;
    }
    #start-instructions ul {
        list-style: none;
        padding-left: 5px;
        margin: 4px 0;
        text-align: left;
    }
    #start-instructions li {
        margin-bottom: 3px;
        line-height: 1.2;
    }
    #start-instructions ul ul {
        padding-left: 15px;
        margin-top: 2px;
    }
    #start-instructions .keys {
        font-size: clamp(1.4em, 3.5vw, 1.7em);
        color: #eee;
        margin-bottom: 5px;
        letter-spacing: 5px;
        display: block;
        text-align: center;
        margin-top: 5px;
    }
    #start-instructions .keys span {
        display: inline-block;
        border: 1px solid #888;
        padding: 0 5px;
        border-radius: 3px;
        min-width: 1.2em;
        text-align: center;
        background: rgba(255,255,255,0.1);
    }

    .menu-icon {
      display: inline-block;
      width: 18px;
      height: 18px;
      margin-right: 6px;
      vertical-align: middle;
      position: relative;
    }

    /* Red "X" */
    .red-x::before,
    .red-x::after {
      content: '';
      position: absolute;
      width: 100%;
      height: 3px;
      background-color: red;
      border-radius: 2px;
      top: 50%;
      left: 0;
      transform-origin: center;
    }
    .red-x::before {
      transform: rotate(45deg);
    }
    .red-x::after {
      transform: rotate(-45deg);
    }

    /* Green Checkmark */
    .green-check::before {
      content: '';
      position: absolute;
      width: 10px;
      height: 3px;
      background-color: #39ff14;
      transform: rotate(-45deg);
      top: 60%;
      left: 15%;
      border-radius: 2px;
    }
    .green-check::after {
      content: '';
      position: absolute;
      width: 5px;
      height: 3px;
      background-color: #39ff14;
      transform: rotate(45deg);
      top: 66%;
      left: 40%;
      border-radius: 2px;
    }

    /* Battery Icon Menu Patch */
    .battery-icon {
       display: inline-block;
       width: 18px;
       height: 18px;
       background-color: #39ff14;
       color: white;
       font-weight: 900;
       font-size: 18px;
       text-align: center;
       line-height: 18px;
       border-radius: 2px;
       margin-right: 6px;
       font-family: monospace;
     }

    /* Vertiport Recharge Pillar Fix */
    .vertiport-pillar-icon {
      display: inline-block;
      vertical-align: middle;
      margin-right: 6px;
      line-height: 1;
    }

    .pillar-line {
      display: block;
      width: 12px;
      height: 4px;
      margin: 2px auto;
      border-radius: 2px;
      box-shadow: 0 0 3px #fff;
    }

    .bar1 { background-color: #eee; }
    .bar2 { background-color: #f5f5f5; }
    .bar3 { background-color: #ffffff; }


    #startButton {
      display: flex;
      align-items: center;
      justify-content: center;
      background: #ff0;
      color: black;
      border: 3px solid #f0f;
      box-shadow: 0 0 8px #ff0, 0 0 15px #f0f;
      font-weight: bold;
      cursor: pointer;
      transition: background-color 0.2s, transform 0.1s, box-shadow 0.3s ease;
      -webkit-tap-highlight-color: transparent;
      animation: pulse 2s infinite ease-in-out;
      text-align: center;
      padding: 0;
      margin: 15px auto 0 auto;
      flex-shrink: 0;
      width: clamp(100px, 25vw, 150px);
      height: clamp(100px, 25vw, 150px);
      border-radius: 50%;
      font-size: clamp(1.1em, 4vw, 1.4em);
    }

    @media (max-width: 768px) {
       #start-screen {
          padding-top: 10px;
          padding-bottom: 10px;
          justify-content: flex-start;
       }
      #startButton {
        width: clamp(180px, 60vw, 280px);
        height: clamp(55px, 9vh, 70px);
        border-radius: 8px !important;
        font-size: clamp(1.1em, 4.5vw, 1.5em);
        margin-top: auto;
        margin-bottom: max(10px, env(safe-area-inset-bottom));
      }
    }

    @keyframes pulse {
        0% { box-shadow: 0 0 8px #ff0, 0 0 15px #f0f; transform: scale(1); }
        50% { box-shadow: 0 0 12px #ff0, 0 0 25px #f0f; transform: scale(1.03); }
        100% { box-shadow: 0 0 8px #ff0, 0 0 15px #f0f; transform: scale(1); }
    }

    #startButton:hover {
       background-color: #fff;
       box-shadow: 0 0 15px #ff0, 0 0 30px #f0f;
       animation-play-state: paused;
    }
    #startButton:active {
      transform: scale(0.97);
      animation: none;
    }

    #game-over-screen button {
      padding: 12px 25px;
      font-size: clamp(1em, 3.5vw, 1.2em);
      background: #ff0;
      color: black;
      border: 2px solid black;
      border-radius: 5px;
      font-weight: bold;
      cursor: pointer;
      margin-top: 15px;
      transition: background-color 0.2s, transform 0.1s;
      -webkit-tap-highlight-color: transparent;
    }
    #game-over-screen button:hover {
       background-color: #fff;
    }
    #game-over-screen button:active {
      transform: scale(0.95);
    }


    #ui-overlay {
      position: absolute;
      top: 15px;
      right: 15px;
      z-index: 5;
      display: none;
      font-size: 14px;
      text-align: right;
      pointer-events: none;
    }

    #branding-watermark {
        position: absolute;
        top: 15px;
        right: 215px;
        height: 55px;
        width: auto;
        opacity: 0.22;
        pointer-events: none;
        z-index: 4;
        display: none;
    }


    .ui-element { margin-bottom: 10px; }
    #battery { width: 80px; height: 25px; border: 2px solid white; background-color: #333; display: inline-block; vertical-align: middle; }
    #battery-level { height: 100%; background-color: #4CAF50; width: 100%; transition: width 0.2s ease-out, background-color 0.3s linear; }
    #score-label, #battery-label { display: inline-block; vertical-align: middle; margin-right: 8px; }

    #game-over-screen { display: none; flex-direction: column; align-items: center; justify-content: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); z-index: 20; text-align: center; padding: 20px; box-sizing: border-box; }

    #game-over-branding {
        display: block;
        width: 70vw;
        max-width: 550px;
        height: auto;
        margin: 0 auto 20px auto;
        opacity: 1.0;
        image-rendering: auto;
        pointer-events: none;
    }

    #game-over-screen h2 { font-size: clamp(1.5em, 4vw, 2em); color: #f44336; text-shadow: 1px 1px #fff; margin-bottom: 20px; }
    #game-over-screen p { font-size: clamp(1em, 3vw, 1.2em); margin-bottom: 15px; }

    #game-over-screen .branding-message {
        font-size: clamp(0.8em, 2.5vw, 1.0em);
        color: #bbb;
        margin: 25px 0;
        line-height: 1.5;
    }
    #game-over-screen .branding-message a {
        color: #0ff;
        text-decoration: none;
        font-weight: bold;
    }
    #game-over-screen .branding-message a:hover {
        text-decoration: underline;
    }

    #mobile-controls-left, #mobile-controls-right {
        position: absolute;
        bottom: clamp(15px, 3vh, 30px);
        z-index: 15;
        display: none;
        user-select: none;
        -webkit-user-select: none;
    }
    #mobile-controls-left { left: clamp(15px, 3vw, 30px); }
    #mobile-controls-right {
        right: clamp(15px, 3vw, 30px);
        flex-direction: row;
        align-items: center;
    }

    .mobile-button {
        display: block;
        width: clamp(80px, 18vw, 100px);
        height: clamp(80px, 18vw, 100px);
        background-color: rgba(200, 200, 200, 0.3);
        border: 2px solid rgba(255, 255, 255, 0.5);
        border-radius: 50%;
        font-size: clamp(28px, 7vw, 40px);
        color: rgba(255, 255, 255, 0.7);
        text-align: center;
        line-height: clamp(80px, 18vw, 100px);
        cursor: pointer;
        pointer-events: auto;
        -webkit-tap-highlight-color: transparent;
    }
    #mobile-controls-left .mobile-button { margin-bottom: clamp(12px, 2.5vh, 18px); }
    #mobile-controls-left .mobile-button:last-child { margin-bottom: 0; }
    #mobile-controls-right .mobile-button { margin-left: clamp(12px, 2.5vw, 18px); }
    #mobile-controls-right .mobile-button:first-child { margin-left: 0; }
    .mobile-button:active { background-color: rgba(255, 255, 255, 0.5); }
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>
<img src="https://placehold.co/800x400/000000/FFFFFF/png?text=HoverRush" id="branding-watermark" alt="HoverRush Logo" style="display: none;" />

<div id="start-screen">
<h1>HoverRush</h1>
<p>A Flying Car Adventure on the Skyway</p>
<p class="tagline">Dodge buildings, catch boosts, and feel the pulse of the sky.</p>
<div id="start-instructions">
<h3>üéØ How to Play:</h3>
<ul style="text-align:left; padding-left: 0;">
<li>Dodge flying obstacles like:</li>
<ul style="padding-left: 20px; margin-top: 5px;">
<li>üçó Chicken legs tossed by feisty sky-street vendors</li>
<li>üåΩ Corn cobs: Because the sky's not safe from snacks!</li>
<li>üê¶ Birds doing wild loop-de-loops</li>
<li>üéà Balloons rising from the streets</li>
</ul>
<li>üí• Hitting anything drains your battery.</li>
<li><span class="menu-icon red-x"></span> If your battery hits zero, it‚Äôs game over.</li>
</ul>
<h3><span class="menu-icon green-check"></span> What to Grab:</h3>
<ul style="text-align:left; padding-left: 0;">
<li><span class="battery-icon">+</span>Floating batteries to recharge</li>
<!-- Recharge Zone Pillar Icon Replacement -->
<li>
  <span class="vertiport-pillar-icon">
    <span class="pillar-line bar1"></span>
    <span class="pillar-line bar2"></span>
    <span class="pillar-line bar3"></span>
  </span>
  Enter recharge zones (auto land and refuel)
</li>
</ul>
<h3>üïπÔ∏è Controls:</h3>
<ul style="text-align:left; padding-left: 0;">
<li>‚å®Ô∏è Arrow keys (desktop)</li>
<li>‚òùÔ∏è Tap arrows (mobile)</li>
</ul>
</div>
<button id="startButton">Start Game</button>
</div>
<div id="ui-overlay">
<div class="ui-element">
<span id="score-label">Score: 0</span>
</div>
<div class="ui-element">
<span id="battery-label">Battery</span>
<div id="battery">
<div id="battery-level"></div>
</div>
</div>
</div>
<div id="game-over-screen">
<img alt="HoverRush Logo" id="game-over-branding" src="https://placehold.co/550x200/000000/FFFFFF/png?text=HoverRush"/>
<h2>Game Over!</h2>
<p id="final-score">Final Score: 0</p>
<p class="branding-message">üöÄ Want to keep flying? <br/> Visit <a href="https://AllThingsFlyingCars.com" target="_blank">AllThingsFlyingCars.com</a> and ride the skyway of the future!</p>
<button id="replayButton">Replay</button>
</div>
<div id="mobile-controls-left">
<div class="mobile-button" id="touch-up">‚Üë</div>
<div class="mobile-button" id="touch-down">‚Üì</div>
</div>
<div id="mobile-controls-right">
<div class="mobile-button" id="touch-left">‚Üê</div>
<div class="mobile-button" id="touch-right">‚Üí</div>
</div>
<script>
    // Canvas & Context
    const gameCanvas = document.getElementById('gameCanvas');
    const ctx = gameCanvas.getContext('2d');

    // UI Elements
    const startScreen = document.getElementById('start-screen');
    const startButton = document.getElementById('startButton');
    const uiOverlay = document.getElementById('ui-overlay');
    const batteryLevelUI = document.getElementById('battery-level');
    const scoreLabel = document.getElementById('score-label');
    const gameOverScreen = document.getElementById('game-over-screen');
    const finalScoreLabel = document.getElementById('final-score');
    const replayButton = document.getElementById('replayButton');
    const mobileControlsLeft = document.getElementById('mobile-controls-left');
    const mobileControlsRight = document.getElementById('mobile-controls-right');
    const touchUpButton = document.getElementById('touch-up');
    const touchDownButton = document.getElementById('touch-down');
    const touchLeftButton = document.getElementById('touch-left');
    const touchRightButton = document.getElementById('touch-right');
    const brandingWatermark = document.getElementById('branding-watermark');
    const gameOverBranding = document.getElementById('game-over-branding');


    // Game State
    let carX = 80, carY = 300, prevCarX = 80, prevCarY = 300;
    let carColor = 'white', carShake = 0;
    let battery = 100, score = 0;
    let keys = {}, prevKeys = {};
    let gameRunning = false, playerControlEnabled = true;
    let animationFrameId = null, frameCount = 0, lowBatteryWarningPlayed = false;
    const BASE_SCROLL_SPEED = 4.0, MAX_SCROLL_SPEED = 7.5, SCROLL_SPEED_INCREMENT = 0.05;
    let currentScrollSpeed = BASE_SCROLL_SPEED;
    const BASE_MUSIC_TEMPO = 160, MAX_MUSIC_TEMPO = 230, MUSIC_TEMPO_INCREMENT = 3;
    let currentMusicTempo = BASE_MUSIC_TEMPO;
    let isChargingSequence = false, chargingPhase = null, targetChargeStation = null;
    let autoPilotStartY = 0, autoPilotProgress = 0, chargeStartTime = 0;
    const CHARGE_DURATION_MS = 2000;
    let isCaptured = false, capturePhase = null, captureTargetBuilding = null;
    let captureStartTime = 0;
    const CAPTURE_HOLD_DURATION_MS = 3000, CAPTURE_BATTERY_DRAIN = 5;
    const CAR_HEIGHT = 30, CAR_WIDTH = 50, MIN_CAR_X = 20;
    let MAX_CAR_X = 300;
    const MOVE_SPEED_Y = 5, MOVE_SPEED_X = 3;
    const BATTERY_DRAIN_RATE = 0.03, COLLISION_BATTERY_COST = 8, BONUS_BATTERY_GAIN = 20;
    const SIDEWALK_HEIGHT = 40;
    const PROJECTILE_SPEED_MULTIPLIER = 1.1, BONUS_SPEED_MULTIPLIER = 0.9, PEDESTRIAN_SPEED_MULTIPLIER = 0.4;
    const CHARGING_TRIGGER_SPAWN_CHANCE = 0.0015, BIRD_SPEED_MULTIPLIER = 1.3;
    const BASE_BIRD_SPAWN_CHANCE = 0.012;
    const BASE_PEDESTRIAN_SPAWN_CHANCE = 0.010;
    const BASE_PROJECTILE_THROW_CHANCE = 0.01;
    const VERTIPORT_SPAWN_CHANCE = 0.01;
    let buildings = [], pedestrians = [], projectiles = [], bonuses = [], birds = [], clouds = [], swarmVehicles = [];
    let cityHeight = 450, playableHeight = 450;
    const PROJECTILE_GRAVITY = 0.15;
    let difficultyMultiplier = 1.0;

    // --- Blimp Variables ---
    let blimps = [];
    let nextBlimpScoreTarget = 10000;
    const BLIMP_SCORE_INTERVAL_MIN = 3500;
    const BLIMP_SCORE_INTERVAL_MAX = 5000;
    const BLIMP_COLLISION_DAMAGE = 25;
    const blimpLogoImage = new Image();
    blimpLogoImage.src = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI4MCIgaGVpZ2h0PSI4MCIgdmlld0JveD0iMCAwIDEwMCAxMDAiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsNSkiPjxwYXRoIGQ9Ik01MCAxMEE0MCA0MCAwIDEgMCA1MCA5MEE0MCA0MCAwIDAgMCA1MCAxMFptMCA3NkEyNiAyNiAwIDEgMSA1MCAyNEEyNiAyNiAwIDAgMSA1MCA4NloiIGZpbGw9IiNmZmYiLz48cGF0aCBkPSJNNjIgMzVINThMNDQgNTlWNDRIMzVWNjVIMzlMNTMgNDFWNTdoOVY2NWg1VjM1WiIgZmlsbD0iI2ZmZiIvPjwvZz48L3N2Zz4=';


    // --- Blimp Theme Audio Variables ---
    let blimpThemeGainNode = null;
    let blimpThemeHighPassFilter = null;
    let blimpThemePeakingFilter = null;
    let blimpThemeNodes = [];
    let blimpThemeLoopTimeoutId = null;
    let blimpThemeIsPlaying = false;
    const BLIMP_THEME_VOLUME = 0.22;
    const BLIMP_THEME_FADE_DURATION = 1.5;
    let blimpThemeNextPlayTime = 0;
    const BLIMP_THEME_REPLAY_MIN_DELAY = 15000;
    const BLIMP_THEME_REPLAY_MAX_DELAY = 30000;

    // --- Escalation Event Flags ---
    let doubleBlimpsTriggered = false;
    let surgeModeActive = false;
    let surgeModeTriggered = false;

    // --- HOT DAWG Obstacle ---
    let hotDawgs = [];
    let explosions = [];
    const HOT_DAWG_SPAWN_CHANCE = 0.008;
    const HOT_DAWG_BATTERY_COST = 25;


    // --- Blimp Class ---
    class Blimp {
        constructor(canvas, playableHeight, logoImage, options = {}, speedMultiplier = 1.0) {
            this.canvas = canvas;
            this.playableHeight = playableHeight;
            this.logoImage = logoImage;
            this.width = options.large ? 350 : 300;
            this.height = options.large ? 150 : 130;
            this.x = this.canvas.width + (options.offsetX || 0);
            this.y = (this.playableHeight * 0.1 + Math.random() * (this.playableHeight * 0.15)) + (options.offsetY || 0);
            this.vx = (-2.5 - Math.random() * 0.5) * speedMultiplier;
            this.bannerLogo = 'ALLTHINGSFLYINGCARS.com ';
            this.collisionDamage = BLIMP_COLLISION_DAMAGE;
            this.bannerWavePhase = Math.random() * Math.PI * 2;
            this.bannerWaveSpeed = 0.04 + Math.random() * 0.02;
            this.bannerWaveAmplitude = 6 + Math.random() * 3;
            this.windowPulsePhase = Math.random() * Math.PI * 2;
            this.windowPulseSpeed = 0.05 + Math.random() * 0.03;
            this.ribPhase = Math.random() * Math.PI * 2;
            this.ribSpeed = 0.02 + Math.random() * 0.01;
            this.bannerScrollOffset = 0;
            this.prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        }

        update() {
            this.x += this.vx;
            this.bannerWavePhase += this.bannerWaveSpeed;
            this.windowPulsePhase += this.windowPulseSpeed;
            this.ribPhase += this.ribSpeed;

            if (!this.prefersReducedMotion) {
                const isSmallScreen = this.canvas.width <= 480;
                const scrollSpeed = isSmallScreen ? 0.35 : 0.8;
                this.bannerScrollOffset += scrollSpeed;
            }
        }

        draw(ctx) {
            const centerX = this.x + this.width / 2;
            const centerY = this.y + this.height / 2;

            // Blimp Body (Yellow with Gradient)
            const bodyGradient = ctx.createLinearGradient(centerX - this.width * 0.2, centerY - this.height * 0.3, centerX + this.width * 0.2, centerY + this.height * 0.3);
            bodyGradient.addColorStop(0, '#FFFDE7');
            bodyGradient.addColorStop(0.5, '#FFDB58');
            bodyGradient.addColorStop(1, '#B8860B');
            ctx.fillStyle = bodyGradient;
            ctx.beginPath();
            ctx.ellipse(centerX, centerY, this.width / 2, this.height / 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Subtle Highlight on top
            ctx.save();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.06)';
            ctx.beginPath();
            ctx.ellipse(centerX, centerY - this.height * 0.20, this.width / 2 * 0.95, this.height / 2 * 0.35, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Subtle Shadow on bottom
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.06)';
            ctx.beginPath();
            ctx.ellipse(centerX, centerY + this.height * 0.20, this.width / 2 * 0.95, this.height / 2 * 0.35, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Curved Rib Lines
            ctx.strokeStyle = 'rgba(100, 80, 30, 0.35)';
            ctx.lineWidth = 2;
            const numRibs = 6;
            for (let i = 1; i <= numRibs; i++) {
                const ribProgress = i / (numRibs + 1);
                const xOffset = (ribProgress - 0.5) * this.width * 0.9;
                const yRadius = this.height / 2 * Math.sqrt(1 - Math.pow(xOffset / (this.width / 2 * 0.95), 2));
                const shimmer = Math.sin(this.ribPhase + i * 0.6) * 1.5;
                ctx.beginPath();
                ctx.moveTo(centerX + xOffset, centerY - yRadius + shimmer);
                ctx.quadraticCurveTo(centerX + xOffset + (Math.random()-0.5)*3 , centerY, centerX + xOffset, centerY + yRadius + shimmer);
                ctx.stroke();
            }
            // Nose cone line
            ctx.strokeStyle = 'rgba(139, 69, 19, 0.4)';
            ctx.beginPath();
            ctx.moveTo(centerX - this.width * 0.48, centerY - this.height * 0.2);
            ctx.quadraticCurveTo(centerX - this.width * 0.52, centerY, centerX - this.width * 0.48, centerY + this.height * 0.2);
            ctx.stroke();

            // Main Body Outline
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.ellipse(centerX, centerY, this.width / 2, this.height / 2, 0, 0, Math.PI * 2);
            ctx.stroke();

             // Gondola (Dark Gray with Shadow)
            const gondolaWidth = this.width * 0.3;
            const gondolaHeight = this.height * 0.25;
            const gondolaX = centerX - gondolaWidth / 2;
            const gondolaY = centerY + this.height * 0.35;

            ctx.save();
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 8;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 4;
            ctx.fillStyle = '#555';
            ctx.fillRect(gondolaX, gondolaY, gondolaWidth, gondolaHeight);
            ctx.restore();

            ctx.strokeStyle = '#333';
            ctx.strokeRect(gondolaX, gondolaY, gondolaWidth, gondolaHeight);

            // Animated Gondola Windows
            const numWindows = 3;
            const windowWidth = gondolaWidth / (numWindows + 2);
            const windowHeight = gondolaHeight * 0.4;
            const windowSpacing = (gondolaWidth - (numWindows * windowWidth)) / (numWindows + 1);
            const windowBaseY = gondolaY + gondolaHeight * 0.25;

            const pulseBrightness = 0.6 + Math.sin(this.windowPulsePhase) * 0.4;
            const windowGlowColor = `rgba(173, 216, 230, ${pulseBrightness * 0.7})`;
            const windowCoreColor = `rgba(220, 240, 255, ${pulseBrightness})`;

            for (let i = 0; i < numWindows; i++) {
                const currentWindowX = gondolaX + windowSpacing + (i * (windowWidth + windowSpacing));
                ctx.fillStyle = windowGlowColor;
                ctx.shadowColor = windowGlowColor;
                ctx.shadowBlur = 6 * pulseBrightness;
                ctx.beginPath();
                ctx.ellipse(currentWindowX + windowWidth/2, windowBaseY + windowHeight/2, windowWidth/2, windowHeight/2, 0, 0, Math.PI*2);
                ctx.fill();
                ctx.shadowBlur = 0;

                ctx.fillStyle = windowCoreColor;
                 ctx.beginPath();
                ctx.ellipse(currentWindowX + windowWidth/2, windowBaseY + windowHeight/2, windowWidth/2.5, windowHeight/2.5, 0, 0, Math.PI*2);
                ctx.fill();
            }

            // Tail Fins (Softer Orange with Shadow)
            ctx.save();
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 5;
            ctx.shadowOffsetX = -2;
            ctx.shadowOffsetY = 2;
            ctx.fillStyle = '#FF8C00';
            const finBaseX = centerX + this.width * 0.35;
            const finTipX = centerX + this.width * 0.50;
            const finW = this.width * 0.15;
            const finH = this.height * 0.45;

            ctx.beginPath();
            ctx.moveTo(finBaseX - finW, centerY - this.height * 0.1);
            ctx.quadraticCurveTo(finBaseX + finW * 0.2, centerY - finH * 0.8, finTipX, centerY - finH/2);
            ctx.quadraticCurveTo(finBaseX + finW * 0.3, centerY, finBaseX, centerY + this.height * 0.1);
            ctx.closePath();
            ctx.fill();
            ctx.restore();

            // Horizontal Center Line (Reinforced)
            ctx.strokeStyle = '#A0522D';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(centerX - this.width/2 * 0.75, centerY);
            ctx.lineTo(centerX + this.width/2 * 0.7, centerY);
            ctx.stroke();

            // Placeholder Logo on Blimp Body - DRAWN LAST TO BE ON TOP
            if (this.logoImage && this.logoImage.complete) {
                ctx.save();
                ctx.globalAlpha = 0.9;
                ctx.filter = 'drop-shadow(0 0 5px white)';
                const logoWidth = 80;
                const logoHeight = this.logoImage.height * (logoWidth / this.logoImage.width);
                ctx.drawImage(this.logoImage, centerX - logoWidth / 2, centerY - logoHeight / 2, logoWidth, logoHeight);
                ctx.restore();
            }

            // Banner (trailing with wave and scrolling text)
            const bannerWidth = 240;
            const bannerHeight = 54;
            const bannerAttachX = centerX + this.width * 0.45;
            const bannerAttachY = centerY;
            const bannerStartX = this.x + this.width + 20;
            const bannerSegments = 10;
            const segmentWidth = bannerWidth / bannerSegments;

            const staticWaveOffsetYForAttach = Math.sin(this.bannerWavePhase) * this.bannerWaveAmplitude;
            const bannerBaseYForAttach = this.y + this.height / 2 - bannerHeight / 2 + staticWaveOffsetYForAttach;
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(bannerAttachX, bannerAttachY - this.height * 0.05);
            ctx.lineTo(bannerStartX, bannerBaseYForAttach + bannerHeight * 0.2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(bannerAttachX, bannerAttachY + this.height * 0.05);
            ctx.lineTo(bannerStartX, bannerBaseYForAttach + bannerHeight * 0.8);
            ctx.stroke();

            ctx.save(); // Save before clipping for banner text
            ctx.fillStyle = '#000'; // Black banner background
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let i = 0; i <= bannerSegments; i++) {
                const waveOffset = Math.sin(performance.now() / 200 + i * 0.5) * this.bannerWaveAmplitude * (i / bannerSegments);
                const currentBannerX = bannerStartX + i * segmentWidth;
                const currentBannerTopY = this.y + this.height / 2 - bannerHeight / 2 + waveOffset;
                if (i === 0) { ctx.moveTo(currentBannerX, currentBannerTopY); } else { ctx.lineTo(currentBannerX, currentBannerTopY); }
            }
            for (let i = bannerSegments; i >= 0; i--) {
                 const waveOffset = Math.sin(performance.now() / 200 + i * 0.5) * this.bannerWaveAmplitude * (i / bannerSegments);
                 const currentBannerX = bannerStartX + i * segmentWidth;
                 const currentBannerBottomY = this.y + this.height / 2 + bannerHeight / 2 + waveOffset;
                 ctx.lineTo(currentBannerX, currentBannerBottomY);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.clip(); // Use the banner path as a clipping mask

            // Scrolling Text Logic
            const isSmallScreen = this.canvas.width <= 480;
            const fontSize = isSmallScreen ? 16 : 14;
            ctx.font = `bold ${fontSize}px 'Courier New', monospace`;
            ctx.fillStyle = '#39ff14';
            ctx.shadowColor = '#39ff14';
            ctx.shadowBlur = 8;
            ctx.textBaseline = 'middle';
            const avgBannerY = this.y + this.height / 2;

            if (this.prefersReducedMotion) {
                ctx.textAlign = 'center';
                ctx.fillText(this.bannerLogo.trim(), bannerStartX + bannerWidth / 2, avgBannerY);
            } else {
                ctx.textAlign = 'left';
                const textMetrics = ctx.measureText(this.bannerLogo);
                const textWidth = textMetrics.width;
                const effectiveOffset = this.bannerScrollOffset % textWidth;
                let textX = bannerStartX - effectiveOffset;
                while (textX < bannerStartX + bannerWidth) {
                    ctx.fillText(this.bannerLogo, textX, avgBannerY);
                    textX += textWidth;
                }
            }
            ctx.restore(); // Restore from clipping

            // Reset text alignment and baseline for other drawings
            ctx.textAlign = 'left';
            ctx.textBaseline = 'alphabetic';

             // Animated Marker Lights
            const blinkInterval = 1500;
            const blinkOn = (Math.floor(performance.now() / (blinkInterval / 2)) % 2 === 0);

            if (blinkOn) {
                const lightRadius = Math.max(1.5, this.width * 0.006);
                const topFinLightX = finTipX;
                const topFinLightY = centerY - finH / 2;
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(topFinLightX, topFinLightY, lightRadius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        collidesWith(rect) {
            return rect.x < this.x + this.width &&
                   rect.x + rect.width > this.x &&
                   rect.y < this.y + this.height &&
                   rect.y + rect.height > this.y;
        }
    }


    // --- Audio Engine ---
    let audioCtx;
    let audioInitialized = false;
    try {
         audioCtx = new (window.AudioContext || window.webkitAudioContext)();
         console.log("AudioContext created. Initial state:", audioCtx.state);
         audioCtx.onstatechange = () => {
             console.log("AudioContext state changed to:", audioCtx.state);
             if (audioCtx.state !== 'running') {
                audioInitialized = false;
                stopAllSounds();
                console.warn("AudioContext state changed to non-running. Audio features may be disabled until next interaction.");
             } else if (audioCtx.state === 'running' && !audioInitialized) {
                console.log("AudioContext resumed automatically. Re-initialization might be needed for nodes.");
                if (initAudio()) {
                    console.log("Audio re-initialized (nodes checked/created) automatically on state change to running.");
                    if (gameRunning && !musicIsPlaying && !isChargingSequence && !isCaptured) {
                        console.log("Restarting music loop checker due to automatic context resume and game state.");
                        startMusicLoopChecker();
                    }
                     if (blimps.length > 0 && gameRunning && !blimpThemeIsPlaying && audioCtx.currentTime >= blimpThemeNextPlayTime) {
                        playBlimpTheme();
                    }
                }
             }
         };
    } catch (e) {
        console.error("FATAL: Web Audio API is not supported in this browser.", e);
        audioCtx = null;
    }

    let musicOscillators = [], engineHumNodes = null;
    let chargingSoundNodes = [], captureSoundNodes = [];
    let musicGainNode = null, musicLowPassFilter = null, reverbNode = null;

    let musicShouldBePlaying = false;
    let musicIsPlaying = false;

    let musicLoopIntervalId = null;
    let nextMusicScheduleTime = 0;
    const musicScheduleLookahead = 0.25;
    const musicCheckIntervalMs = 200;
    let currentLoopLengthSeconds = 0;

    function initAudio() {
        if (!audioCtx) { console.warn("initAudio: No AudioContext."); return false; }
        if (audioCtx.state === 'suspended') {
            console.warn("initAudio: Context suspended, attempting resume...");
            audioCtx.resume().then(() => {
                 console.log("initAudio: Context resumed successfully during init attempt. Current state:", audioCtx.state);
                 if (audioCtx.state === 'running' && !audioInitialized) {
                     return initAudioInternal();
                 }
            }).catch(err => { console.error("initAudio: Error resuming suspended context:", err); return false; });
            return false;
        }
        if (audioCtx.state === 'running') { return initAudioInternal(); }
        console.warn(`initAudio: Unexpected state ${audioCtx.state}. Cannot initialize.`); return false;
    }

    function initAudioInternal() {
        if (!audioCtx || audioCtx.state !== 'running') { console.error("initAudioInternal: Context not ready. State:", audioCtx?.state); return false; }
        if (audioInitialized) { console.log("initAudioInternal: Already initialized."); return true; }
        console.log("initAudioInternal: Context running, initializing nodes...");
        if (setupMasterAudioNodes()) {
             audioInitialized = true;
             console.log("initAudioInternal: Success. Audio system ready.");
             return true;
        } else {
             console.error("initAudioInternal: setupMasterAudioNodes failed.");
             return false;
        }
    }

    function setupMasterAudioNodes() {
        if (!audioCtx || audioCtx.state !== 'running') { console.error("setupMasterAudioNodes: Context not ready. State:", audioCtx?.state); return false; }
        if (!musicGainNode || !musicLowPassFilter || !reverbNode) {
            try {
                musicGainNode = audioCtx.createGain();
                musicLowPassFilter = audioCtx.createBiquadFilter(); musicLowPassFilter.type = 'lowpass'; musicLowPassFilter.frequency.value = 20000;
                const reverbDelay = audioCtx.createDelay(0.5); reverbDelay.delayTime.value = 0.15; const reverbFeedback = audioCtx.createGain(); reverbFeedback.gain.value = 0.35; const reverbFilter = audioCtx.createBiquadFilter(); reverbFilter.type = 'lowpass'; reverbFilter.frequency.value = 2500; reverbDelay.connect(reverbFeedback).connect(reverbFilter).connect(reverbDelay); reverbNode = { input: reverbDelay, output: reverbFilter };
                musicGainNode.connect(musicLowPassFilter).connect(audioCtx.destination);
                const reverbOutputGain = audioCtx.createGain(); reverbOutputGain.gain.value = 0.25; reverbNode.output.connect(reverbOutputGain).connect(audioCtx.destination);
                musicGainNode.gain.value = 0.45;
                console.log("setupMasterAudioNodes: Master audio nodes created successfully."); return true;
            } catch (error) { console.error("setupMasterAudioNodes: Error creating master audio nodes:", error); musicGainNode = null; musicLowPassFilter = null; reverbNode = null; return false; }
        } else {
             console.log("setupMasterAudioNodes: Master audio nodes already exist."); return true;
        }
    }

    function triggerHapticFeedback(duration = 50) { /* No haptics */ }

    function playTone(freq, duration = 0.2, type = 'square', vol = 0.3, when = 0, options = {}) {
        if (!audioInitialized || !audioCtx || audioCtx.state !== 'running') { return null; }
        try {
            const startTime = (options.absoluteTime !== undefined) ? options.absoluteTime : audioCtx.currentTime + when;
            const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); const outputNode = options.outputNode || audioCtx.destination;
            if (startTime < audioCtx.currentTime) {
                 console.warn(`playTone: Skipping note scheduled in the past. Freq: ${freq}, Scheduled: ${startTime.toFixed(3)}, Now: ${audioCtx.currentTime.toFixed(3)}`);
                 return null;
            }
            osc.type = type;
            if (options.detune) osc.detune.setValueAtTime(options.detune, startTime);
            if (options.frequency instanceof AudioParam) { options.frequency.cancelScheduledValues(startTime); options.frequency.setValueAtTime(options.frequency.value, startTime); options.frequency.connect(osc.frequency); } else { osc.frequency.setValueAtTime(freq, startTime); }

            gain.gain.setValueAtTime(vol, startTime);
            if (options.rampTo !== undefined && duration > 0) {
                gain.gain.linearRampToValueAtTime(options.rampTo, startTime + duration * 0.8);
                gain.gain.linearRampToValueAtTime(0.001, startTime + duration);
            } else if (duration > 0) {
                gain.gain.exponentialRampToValueAtTime(0.001, startTime + duration);
            }

            osc.connect(gain).connect(outputNode);
            osc.start(startTime);
            const stopTime = startTime + duration;
            if (duration > 0 && stopTime > audioCtx.currentTime) { osc.stop(stopTime); }
            else if (duration <= 0) { /* Indefinite tone, must be stopped manually or by parent node */ }
            else { try { osc.stop(); } catch (e) {} } // Stop if somehow scheduled in past for 0 duration

            if (options.frequency instanceof AudioParam) { setTimeout(() => { try { options.frequency.disconnect(osc.frequency); } catch(e) {} }, duration * 1000 + 100); }
            return { osc, gain };
        } catch (error) { console.error("playTone Error:", error, {freq, duration, type, vol, when, options}); return null; }
    }

    function playStartJingle() { if (!audioInitialized) return; const now = audioCtx.currentTime; const vol = 0.4; const dur = 0.2; playTone(110, dur + 0.2, 'sawtooth', vol * 0.15, 0); playTone(440, dur, 'square', vol, 0.10); playTone(1760, dur * 0.8, 'sine', vol * 0.20, 0.3, { rampTo: 0 }); if (reverbNode) playTone(1760, dur * 0.5, 'sine', vol * 0.4, 0.35, { outputNode: reverbNode.input }); }
    function playCollisionSound() { if (!audioInitialized) return; const now = audioCtx.currentTime; const noiseDur = 0.15; try { const noiseEnv = audioCtx.createGain(); noiseEnv.connect(audioCtx.destination); noiseEnv.gain.setValueAtTime(0.3, now); noiseEnv.gain.exponentialRampToValueAtTime(0.001, now + noiseDur); const noiseSrc = audioCtx.createBufferSource(); const bufferSize = audioCtx.sampleRate * noiseDur; const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate); const data = buffer.getChannelData(0); for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1; noiseSrc.buffer = buffer; noiseSrc.connect(noiseEnv); noiseSrc.start(now); noiseSrc.stop(now + noiseDur); } catch (e) { console.error("Error playing collision noise:", e); } playTone(987.77, 0.1, 'triangle', 0.25, 0.02); for(let i=0; i<3; i++) { playTone(2000, 0.03, 'noise', 0.08, 0.1 + i * 0.04); } }
    function playBatteryPickupSound() { playTone(329.63, 0.08, 'sine', 0.35, 0.0); playTone(392.00, 0.08, 'sine', 0.35, 0.08); playTone(523.25, 0.15, 'sine', 0.4, 0.16); }
    function playLowBatteryWarning() { if (!lowBatteryWarningPlayed) { playTone(880, 0.08, 'square', 0.25, 0); playTone(880, 0.08, 'square', 0.25, 0.15); lowBatteryWarningPlayed = true; setTimeout(() => { lowBatteryWarningPlayed = false; }, 5000); } }
    // Reduced Bonus Flourish Volume
    function playBonusFlourish() { const baseFreq = 783.99; const vol = 0.12; playTone(baseFreq, 0.08, 'triangle', vol, 0.0); playTone(baseFreq * 1.25, 0.08, 'triangle', vol, 0.08); playTone(baseFreq * 1.5, 0.12, 'triangle', vol, 0.16); }
    function playEngineHum() { if (engineHumNodes || !audioInitialized || !audioCtx || audioCtx.state !== 'running') return; try { const baseFreq = 60; const humGain = audioCtx.createGain(); const panner = audioCtx.createStereoPanner(); const filter = audioCtx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 5000; const humOsc = audioCtx.createOscillator(); humOsc.type = 'sawtooth'; humOsc.frequency.setValueAtTime(baseFreq, audioCtx.currentTime); const detuneOsc = audioCtx.createOscillator(); detuneOsc.frequency.value = 5; const detuneGain = audioCtx.createGain(); detuneGain.gain.value = 15; humGain.gain.value = 0.06; detuneOsc.connect(detuneGain).connect(humOsc.detune); humOsc.connect(filter).connect(panner).connect(humGain).connect(audioCtx.destination); humOsc.start(); detuneOsc.start(); engineHumNodes = { osc: humOsc, gain: humGain, panner: panner, filter: filter, detuneOsc: detuneOsc }; } catch (e) { console.error("Error starting engine hum:", e); engineHumNodes = null; } }
    function stopEngineHum() { if (!engineHumNodes) return; try { const now = audioCtx.currentTime; engineHumNodes.gain.gain.cancelScheduledValues(now); engineHumNodes.gain.gain.setTargetAtTime(0, now, 0.01); engineHumNodes.osc.stop(now + 0.05); if (engineHumNodes.detuneOsc) engineHumNodes.detuneOsc.stop(now + 0.05); } catch(e) {} engineHumNodes = null; }
    function modulateEngineHum(batteryPercent, vertDelta, horzDelta) { if (!engineHumNodes || !audioInitialized || !audioCtx || audioCtx.state !== 'running') return; try { const now = audioCtx.currentTime; const baseFreq = 60; const pitchRange = 20; const pitchMod = (vertDelta / MOVE_SPEED_Y) * pitchRange; engineHumNodes.osc.frequency.linearRampToValueAtTime(baseFreq + pitchMod, now + 0.1); let panValue = 0; if (keys['ArrowLeft'] || keys['a']) panValue = -0.6; if (keys['ArrowRight'] || keys['d']) panValue = 0.6; engineHumNodes.panner.pan.linearRampToValueAtTime(panValue, now + 0.05); const minVol = 0.05; const maxVol = 0.10; const targetVol = maxVol - (batteryPercent / 100) * (maxVol - minVol); engineHumNodes.gain.gain.linearRampToValueAtTime(targetVol, now + 0.2); const minFilterFreq = 800; const maxFilterFreq = 5000; const targetFilterFreq = (batteryPercent < 30) ? minFilterFreq + (batteryPercent/30) * (1500 - minFilterFreq) : maxFilterFreq; engineHumNodes.filter.frequency.linearRampToValueAtTime(targetFilterFreq, now + 0.3); } catch(e) { console.error("Error modulating engine hum:", e); stopEngineHum(); } }
    function playDodgeSound(direction) { playTone(600 + direction * 100, 0.05, 'noise', 0.05, 0); }
    function playPullDownSound() { playTone(400, 1.0, 'sawtooth', 0.35, 0, { rampTo: 80 }); playTone(150, 1.0, 'square', 0.15, 0.1, { rampTo: 40, detune: -30 }); playTone(55, 1.2, 'sine', 0.12, 0); }
    function playChargingSound() { if (!audioInitialized) return; stopChargingSound(); const baseFreq = 130.81; const chord = [0, 4, 7, 12]; const vol = 0.20; const noteDur = 0.1; let delay = 0; for(let i=0; i<8; i++) { const interval = chord[i % chord.length]; const freq = baseFreq * Math.pow(2, interval / 12); const node = playTone(freq, noteDur * 0.9, 'sine', vol * (1 - (i%4)*0.1), delay); if(node) chargingSoundNodes.push(node); delay += noteDur; } chargingSoundNodes.push(setTimeout(playChargingSound, delay * 1000)); }
    function stopChargingSound() { chargingSoundNodes.forEach(item => { if (typeof item === 'number') clearTimeout(item); else if (item && item.osc) try { item.osc.stop(audioCtx.currentTime); item.gain.gain.cancelScheduledValues(audioCtx.currentTime); item.gain.gain.setValueAtTime(0, audioCtx.currentTime);} catch (e) {} }); chargingSoundNodes = []; }
    function playChargeCompleteSound() { playTone(523.25, 0.1, 'triangle', 0.4, 0.0); playTone(659.25, 0.1, 'triangle', 0.4, 0.1); playTone(783.99, 0.1, 'triangle', 0.4, 0.2); playTone(1046.50, 0.25,'triangle', 0.5, 0.3); }
    function playLaunchSound() { playTone(300, 0.5, 'sawtooth', 0.5, 0, { rampTo: 2500 }); playTone(400, 0.6, 'noise', 0.3, 0.05, { rampTo: 0.01 }); }
    function playGameOverFanfare() { const now = audioCtx.currentTime; const vol = 0.25; const notes = [ { freq: 440.00, delay: 0.0, dur: 0.3 }, { freq: 349.23, delay: 0.3, dur: 0.3 }, { freq: 293.66, delay: 0.6, dur: 0.3 }, { freq: 261.63, delay: 0.9, dur: 0.6 }, ]; notes.forEach(n => playTone(n.freq, n.dur, 'triangle', vol, n.delay, { rampTo: 0.001 })); console.log("Playing soft game over fanfare"); }
    function playWaveBeamSound(building) { playTone(1500, 0.1, 'sine', 0.08, 0, { detune: 200 }); playTone(1800, 0.1, 'sine', 0.08, 0.05, { detune: -150 }); }
    function playLockOnSound() { playTone(523.25, 0.1, 'square', 0.35, 0); playTone(369.99, 0.1, 'square', 0.35, 0.05); }

    function playVertiportPowerDownSound() {
        if (!audioInitialized || !audioCtx || audioCtx.state !== 'running') return;
        const startFreq = 440; const endFreq = 80; const rampDuration = 1.5; const soundDuration = rampDuration + 0.2; const vol = 0.25;
        const node = playTone(startFreq, soundDuration, 'sine', vol, 0, { rampTo: 0.001 });
        if (node && node.osc) {
            captureSoundNodes.push(node);
            try {
                const now = audioCtx.currentTime;
                node.osc.frequency.setValueAtTime(startFreq, now);
                node.osc.frequency.linearRampToValueAtTime(endFreq, now + rampDuration);
            } catch(e) { console.error("Error ramping vertiport power down sound:", e); }
        }
    }

    function playCaptureHoldingPulse() { playTone(220, 0.08, 'sine', 0.12, Math.random() * 0.2); playTone(330, 0.08, 'sine', 0.08, 0.15 + Math.random() * 0.2); }
    function playCaptureReleaseChime() { playTone(329.63, 0.1, 'triangle', 0.35, 0); playTone(392.00, 0.1, 'triangle', 0.35, 0.1); playTone(523.25, 0.2, 'triangle', 0.4, 0.2); }
    function stopCaptureSounds() { captureSoundNodes.forEach(item => { if (item && item.osc) try { item.osc.stop(audioCtx.currentTime); item.gain.gain.cancelScheduledValues(audioCtx.currentTime); item.gain.gain.setValueAtTime(0, audioCtx.currentTime);} catch (e) {} }); captureSoundNodes = []; }
    function playVertiportRefuelSound() { const now = audioCtx.currentTime; const vol = 0.2; playTone(1200, 0.05, 'square', vol * 0.8, 0.0, { detune: 100 }); playTone(1500, 0.05, 'square', vol * 0.7, 0.07); for (let i = 0; i < 4; i++) { playTone(200 + Math.random() * 100, 0.1, 'sine', vol * 0.5, 0.2 + i * 0.08 + Math.random() * 0.04, { detune: (Math.random() - 0.5) * 300 }); } if (!audioInitialized || !audioCtx) return; try { const riseOsc = audioCtx.createOscillator(); const riseGain = audioCtx.createGain(); riseOsc.type = 'triangle'; riseOsc.frequency.setValueAtTime(200, now + 0.4); riseOsc.frequency.linearRampToValueAtTime(800, now + 0.4 + 0.6); riseGain.gain.setValueAtTime(0, now + 0.4); riseGain.gain.linearRampToValueAtTime(vol * 1.1, now + 0.4 + 0.2); riseGain.gain.linearRampToValueAtTime(0.001, now + 0.4 + 0.6); riseOsc.connect(riseGain).connect(audioCtx.destination); riseOsc.start(now + 0.4); riseOsc.stop(now + 0.4 + 0.6); } catch(e) { console.error("Error playing refuel sound rise:", e); } }
    function playCollisionDissonance() { playTone(450, 0.15, 'sawtooth', 0.2, 0, { detune: 50 }); playTone(150, 0.2, 'square', 0.15, 0.02); }
    function applyLowBatteryMusicFilter(isLow) { if (!musicLowPassFilter || !audioInitialized || !audioCtx || audioCtx.state !== 'running') return; const targetFreq = isLow ? 800 : 20000; const targetQ = isLow ? 5 : 1; const now = audioCtx.currentTime; try { musicLowPassFilter.frequency.cancelScheduledValues(now); musicLowPassFilter.Q.cancelScheduledValues(now); musicLowPassFilter.frequency.linearRampToValueAtTime(targetFreq, now + 0.5); musicLowPassFilter.Q.linearRampToValueAtTime(targetQ, now + 0.5); } catch(e) { console.error("Error applying low battery filter:", e); } }

    function playExplosionSound() { if (!audioInitialized) return; playTone(100, 0.3, 'noise', 0.5, 0); playTone(400, 0.2, 'sawtooth', 0.3, 0, { rampTo: 50 }); }
    function playSurgeSound() { if (!audioInitialized) return; playTone(40, 2.0, 'sine', 0.2, 0, { rampTo: 0.01 }); }

    function scheduleMusicBlock() {
        if (!audioInitialized || !audioCtx || audioCtx.state !== 'running' || !musicGainNode) { console.warn("scheduleMusicBlock: Cannot schedule, audio not ready."); stopBackgroundMusic(); return; }
        musicOscillators.forEach(item => { if (item && item.osc && typeof item.osc.stop === 'function') { try { item.osc.stop(audioCtx.currentTime); } catch (e) {} } }); musicOscillators = [];
        try {
            const tempo = currentMusicTempo; const quarterNoteTime = 60 / tempo; const measureTime = quarterNoteTime * 4; const loopLengthSeconds = measureTime * 8; currentLoopLengthSeconds = loopLengthSeconds;
            const blockStartTime = nextMusicScheduleTime + musicScheduleLookahead;
            const pulseVol = 0.25;
            for (let t = 0; t < loopLengthSeconds; t += quarterNoteTime) {
                 const scheduleTime = blockStartTime + t;
                 const kickNode = playTone(80, 0.1, 'sine', pulseVol * 1.2, 0, { outputNode: musicGainNode, rampTo: 0.01, absoluteTime: scheduleTime });
                 const kickClickNode = playTone(80, 0.05, 'noise', pulseVol * 0.5, 0, { outputNode: musicGainNode, absoluteTime: scheduleTime });
                 const snareNode = playTone(250, 0.1, 'noise', pulseVol * 0.8, 0, { outputNode: musicGainNode, rampTo: 0.01, absoluteTime: scheduleTime + quarterNoteTime });
                 if (kickNode) musicOscillators.push(kickNode); if (kickClickNode) musicOscillators.push(kickClickNode); if (snareNode) musicOscillators.push(snareNode);
            }
            const bassNotes = [65.41, 73.42, 87.31, 98.00]; const bassVol = 0.35; const bar = Math.floor((blockStartTime / measureTime)) % 8; const bassNoteIndex = Math.floor(bar / 2) % bassNotes.length; const bassFreq = bassNotes[bassNoteIndex];
            for (let t = 0; t < loopLengthSeconds; t += (quarterNoteTime / 2)) {
                if (t % (quarterNoteTime * 2) < quarterNoteTime) {
                    const scheduleTime = blockStartTime + t; const node = playTone(bassFreq, (quarterNoteTime / 2) * 0.8, 'sawtooth', bassVol, 0, { outputNode: musicGainNode, absoluteTime: scheduleTime }); if (node) musicOscillators.push(node);
                }
            }
            const melodyVol = 0.15; const arpNotes = (bar < 4) ? [0, 3, 7, 10] : [0, 4, 7, 12]; const arpBaseFreq = 261.63;
            for (let t = 0; t < loopLengthSeconds; t += (quarterNoteTime / 4)) {
                const scheduleTime = blockStartTime + t; const arpNoteIndex = Math.floor(t / (quarterNoteTime / 4)) % arpNotes.length; const freq = arpBaseFreq * Math.pow(2, arpNotes[arpNoteIndex] / 12); const node = playTone(freq, (quarterNoteTime / 4) * 0.7, 'triangle', melodyVol, 0, { outputNode: musicGainNode, absoluteTime: scheduleTime }); if (node) musicOscillators.push(node);
            }
            const blockEndTime = blockStartTime + loopLengthSeconds; nextMusicScheduleTime = blockEndTime - musicScheduleLookahead;
        } catch (error) { console.error("Error scheduling background music block:", error); stopBackgroundMusic(); }
    }

    function checkMusicSchedule() {
        if (!gameRunning || !audioInitialized || !audioCtx || audioCtx.state !== 'running' || !musicShouldBePlaying || isChargingSequence || isCaptured) {
            if (musicIsPlaying) stopBackgroundMusic();
            return;
        }
        const currentTime = audioCtx.currentTime;
        const lastBlockEndTime = nextMusicScheduleTime + musicScheduleLookahead;
        if (currentTime > lastBlockEndTime + 1.0) { console.warn(`Music loop checker significantly delayed. Resetting schedule time.`); nextMusicScheduleTime = currentTime; }
        if (currentTime >= nextMusicScheduleTime) { scheduleMusicBlock(); }
    }

    function startMusicLoopChecker() {
        if (!audioInitialized || !audioCtx || audioCtx.state !== 'running') { console.warn("startMusicLoopChecker: Cannot start, audio not ready."); return; }
        if (musicLoopIntervalId !== null) { console.log("startMusicLoopChecker: Loop checker already running."); return; }

        musicShouldBePlaying = true;
        musicIsPlaying = true;
        console.log(`startMusicLoopChecker: Starting. musicShouldBePlaying: ${musicShouldBePlaying}, musicIsPlaying: ${musicIsPlaying}`);
        nextMusicScheduleTime = audioCtx.currentTime;
        scheduleMusicBlock();
        musicLoopIntervalId = setInterval(checkMusicSchedule, musicCheckIntervalMs);
    }

    function stopBackgroundMusic() {
        if (musicLoopIntervalId !== null) {
            clearInterval(musicLoopIntervalId);
            musicLoopIntervalId = null;
        }
        musicOscillators.forEach(item => { if (item && item.osc && typeof item.osc.stop === 'function') { try { if(item.gain && typeof item.gain.gain.cancelScheduledValues === 'function') { item.gain.gain.cancelScheduledValues(audioCtx.currentTime); item.gain.gain.setTargetAtTime(0.0001, audioCtx.currentTime, 0.005); } item.osc.stop(audioCtx.currentTime + 0.02); } catch (e) {} } }); musicOscillators = [];

        musicIsPlaying = false;
        musicShouldBePlaying = false;
        console.log(`stopBackgroundMusic: Stopped. musicShouldBePlaying: ${musicShouldBePlaying}, musicIsPlaying: ${musicIsPlaying}, Cleared Interval ID.`);
        nextMusicScheduleTime = 0; currentLoopLengthSeconds = 0;
    }

    function playBlimpTheme() {
        if (!audioInitialized || !audioCtx || audioCtx.state !== 'running') return;

        if (audioCtx.currentTime < blimpThemeNextPlayTime) {
            return;
        }
        blimpThemeIsPlaying = true;

        try {
            if (!blimpThemeGainNode) {
                blimpThemeGainNode = audioCtx.createGain();
                blimpThemeGainNode.gain.setValueAtTime(0, audioCtx.currentTime); // Start silent for fade-in
            }

            // Ensure filters are (re)created and connected correctly if not already
            if (!blimpThemeHighPassFilter) {
                blimpThemeHighPassFilter = audioCtx.createBiquadFilter();
                blimpThemeHighPassFilter.type = 'highpass';
                blimpThemeHighPassFilter.frequency.setValueAtTime(400, audioCtx.currentTime);
            }
            if (!blimpThemePeakingFilter) {
                blimpThemePeakingFilter = audioCtx.createBiquadFilter();
                blimpThemePeakingFilter.type = 'peaking';
                blimpThemePeakingFilter.frequency.setValueAtTime(2500, audioCtx.currentTime);
                blimpThemePeakingFilter.Q.setValueAtTime(1.5, audioCtx.currentTime);
                blimpThemePeakingFilter.gain.setValueAtTime(3, audioCtx.currentTime); // +3dB gain
            }

            // Ensure correct connection path: Gain -> HPF -> Peaking -> Destination
            try { blimpThemeGainNode.disconnect(); } catch(e) {} // Disconnect from any previous routes
            try { blimpThemeHighPassFilter.disconnect(); } catch(e) {}
            try { blimpThemePeakingFilter.disconnect(); } catch(e) {}

            blimpThemeGainNode.connect(blimpThemeHighPassFilter);
            blimpThemeHighPassFilter.connect(blimpThemePeakingFilter);
            blimpThemePeakingFilter.connect(audioCtx.destination);

            // Fade in the main blimp theme volume (controlled by blimpThemeGainNode)
            blimpThemeGainNode.gain.cancelScheduledValues(audioCtx.currentTime);
            blimpThemeGainNode.gain.setValueAtTime(blimpThemeGainNode.gain.value, audioCtx.currentTime); // Set to current value to avoid clicks
            blimpThemeGainNode.gain.linearRampToValueAtTime(BLIMP_THEME_VOLUME, audioCtx.currentTime + BLIMP_THEME_FADE_DURATION);

            scheduleBlimpArpeggio();
        } catch (e) {
            console.error("Error in playBlimpTheme setup:", e);
            blimpThemeIsPlaying = false;
            if (blimpThemeGainNode) { try { blimpThemeGainNode.disconnect(); } catch(_) {} blimpThemeGainNode = null; }
            if (blimpThemeHighPassFilter) { try { blimpThemeHighPassFilter.disconnect(); } catch(_) {} blimpThemeHighPassFilter = null; }
            if (blimpThemePeakingFilter) { try { blimpThemePeakingFilter.disconnect(); } catch(_) {} blimpThemePeakingFilter = null; }
        }
    }


    function scheduleBlimpArpeggio() {
        if (!blimpThemeIsPlaying || !blimpThemeGainNode || !audioCtx || audioCtx.state !== 'running' || blimps.length === 0) {
            stopBlimpTheme(true);
            return;
        }

        blimpThemeNodes.forEach(item => {
            if (item && item.osc) try { item.osc.stop(audioCtx.currentTime); } catch (e) {}
        });
        blimpThemeNodes = [];

        // Reduced Blimp Volume
        const arpSequence = [
            { freq: 783.99, dur: 0.12, type: 'triangle', vol: 0.25 }, // G5
            { freq: 1046.50, dur: 0.12, type: 'sine', vol: 0.25 },   // C6
            { freq: 932.33, dur: 0.12, type: 'triangle', vol: 0.25 },// A#5/Bb5
            { freq: 783.99, dur: 0.12, type: 'sine', vol: 0.25 },   // G5
            { freq: 659.25, dur: 0.18, type: 'triangle', vol: 0.25 }, // E5 (longer hold)
        ];
        const shortPauseBetweenNotes = 0.04;

        let currentArpeggioPlayDuration = 0;
        const arpPlayStartTime = audioCtx.currentTime;

        for (let i = 0; i < arpSequence.length; i++) {
            const note = arpSequence[i];
            const node = playTone(note.freq, note.dur, note.type, note.vol,
                                0,
                                {
                                  outputNode: blimpThemeGainNode, // Notes go into the GainNode, which is then filtered
                                  absoluteTime: arpPlayStartTime + currentArpeggioPlayDuration,
                                  rampTo: 0.005
                                });
            if (node) blimpThemeNodes.push(node);
            currentArpeggioPlayDuration += note.dur + shortPauseBetweenNotes;
        }

        const randomCooldownDurationSeconds = (BLIMP_THEME_REPLAY_MIN_DELAY + Math.random() * (BLIMP_THEME_REPLAY_MAX_DELAY - BLIMP_THEME_REPLAY_MIN_DELAY)) / 1000;
        blimpThemeNextPlayTime = arpPlayStartTime + currentArpeggioPlayDuration + randomCooldownDurationSeconds;

        if (blimpThemeLoopTimeoutId) clearTimeout(blimpThemeLoopTimeoutId);

        const delayForThisLoopIterationSeconds = currentArpeggioPlayDuration + randomCooldownDurationSeconds;

        blimpThemeLoopTimeoutId = setTimeout(() => {
            if (blimps.length > 0 && blimpThemeIsPlaying && audioCtx.state === 'running') {
                playBlimpTheme();
            }
        }, delayForThisLoopIterationSeconds * 1000);
    }


    function stopBlimpTheme(immediate = false) {
        if (!blimpThemeIsPlaying && !blimpThemeGainNode && !blimpThemeHighPassFilter && !blimpThemePeakingFilter) {
            return;
        }

        blimpThemeIsPlaying = false;

        if (blimpThemeLoopTimeoutId) {
            clearTimeout(blimpThemeLoopTimeoutId);
            blimpThemeLoopTimeoutId = null;
        }

        const cleanupAudioNode = (nodeRef) => {
            if (nodeRef.node) {
                try { nodeRef.node.disconnect(); } catch(_) {}
                nodeRef.node = null;
            }
        };
        
        let gainNodeToFade = blimpThemeGainNode;

        if (!audioCtx || audioCtx.state !== 'running' || !gainNodeToFade) {
            blimpThemeNodes.forEach(item => { if (item && item.osc) try { item.osc.stop(); } catch(_) {} });
            blimpThemeNodes = [];
            cleanupAudioNode({node: blimpThemeGainNode}); blimpThemeGainNode = null;
            cleanupAudioNode({node: blimpThemeHighPassFilter}); blimpThemeHighPassFilter = null;
            cleanupAudioNode({node: blimpThemePeakingFilter}); blimpThemePeakingFilter = null;
            return;
        }

        const fadeDuration = immediate ? 0.05 : BLIMP_THEME_FADE_DURATION;
        const now = audioCtx.currentTime;

        try {
            gainNodeToFade.gain.cancelScheduledValues(now);
            gainNodeToFade.gain.setValueAtTime(gainNodeToFade.gain.value, now);
            gainNodeToFade.gain.linearRampToValueAtTime(0.0001, now + fadeDuration);

            const cleanupTime = (fadeDuration + 0.2) * 1000;
            setTimeout(() => {
                blimpThemeNodes.forEach(item => { if (item && item.osc) try { item.osc.stop(); } catch(_) {} });
                blimpThemeNodes = [];
                cleanupAudioNode({node: blimpThemeGainNode}); blimpThemeGainNode = null;
                cleanupAudioNode({node: blimpThemeHighPassFilter}); blimpThemeHighPassFilter = null;
                cleanupAudioNode({node: blimpThemePeakingFilter}); blimpThemePeakingFilter = null;
            }, cleanupTime);
        } catch(e) {
            console.error("Error stopping blimp theme audio components:", e);
            blimpThemeNodes.forEach(item => { if (item && item.osc) try { item.osc.stop(); } catch(_) {} });
            blimpThemeNodes = [];
            cleanupAudioNode({node: blimpThemeGainNode}); blimpThemeGainNode = null;
            cleanupAudioNode({node: blimpThemeHighPassFilter}); blimpThemeHighPassFilter = null;
            cleanupAudioNode({node: blimpThemePeakingFilter}); blimpThemePeakingFilter = null;
        }
    }

    function stopAllSounds() {
        console.log("Stopping all sounds...");
        stopBackgroundMusic();
        stopEngineHum();
        stopChargingSound();
        stopCaptureSounds();
        stopBlimpTheme(true); // Immediate stop for blimp theme
        if (musicGainNode && audioCtx && audioCtx.state === 'running') { musicGainNode.gain.cancelScheduledValues(audioCtx.currentTime); musicGainNode.gain.setValueAtTime(0.45, audioCtx.currentTime); }
        if (musicLowPassFilter && audioCtx && audioCtx.state === 'running') { musicLowPassFilter.frequency.cancelScheduledValues(audioCtx.currentTime); musicLowPassFilter.frequency.setValueAtTime(20000, audioCtx.currentTime); musicLowPassFilter.Q.cancelScheduledValues(audioCtx.currentTime); musicLowPassFilter.Q.setValueAtTime(1, audioCtx.currentTime); }
    }

    function updateBatteryUI() { const clampedBattery = Math.max(0, Math.min(battery, 100)); batteryLevelUI.style.width = `${clampedBattery}%`; const isLow = clampedBattery < 20; if (isLow) { batteryLevelUI.style.backgroundColor = '#f44336'; if (gameRunning && !isChargingSequence && !isCaptured) playLowBatteryWarning(); } else if (clampedBattery < 50) { batteryLevelUI.style.backgroundColor = '#ffeb3b'; lowBatteryWarningPlayed = false; } else { batteryLevelUI.style.backgroundColor = '#4CAF50'; lowBatteryWarningPlayed = false; } applyLowBatteryMusicFilter(isLow && !isChargingSequence && !isCaptured); }
    function updateScoreUI() { scoreLabel.textContent = `Score: ${score}`; }
    function triggerShake(duration = 5) { carShake = duration; }
    function calculateDimensions() { playableHeight = gameCanvas.height - SIDEWALK_HEIGHT; cityHeight = playableHeight; MAX_CAR_X = gameCanvas.width * 0.4; }

    function spawnBuilding(forceX = null) { const isVertiport = Math.random() < VERTIPORT_SPAWN_CHANCE && !buildings.some(b => b.isVertiport); const minWidth = isVertiport ? 100 : 60; const maxWidth = isVertiport ? 150 : 180; const minHeight = isVertiport ? playableHeight * 0.7 : 100; const maxHeight = isVertiport ? playableHeight * 0.85 : playableHeight * 0.65; const gap = 40 + Math.random() * 60; const lastBuilding = buildings[buildings.length - 1]; let nextX = forceX !== null ? forceX : (lastBuilding ? lastBuilding.x + lastBuilding.width + gap : gameCanvas.width + 50); const height = minHeight + Math.random() * (maxHeight - minHeight); buildings.push({ x: nextX, y: gameCanvas.height - height, width: minWidth + Math.random() * (maxWidth - minWidth), height: height, color: isVertiport ? '#607D8B' : `hsl(${190 + Math.random()*50}, 25%, ${15 + Math.random()*15}%)`, isVertiport: isVertiport, wavePhase: Math.random() * Math.PI * 2 }); }
    function updateBuildings() { for (let i = buildings.length - 1; i >= 0; i--) { const b = buildings[i]; b.x -= currentScrollSpeed; if (b.isVertiport) b.wavePhase += 0.1; if (b.x + b.width < 0) buildings.splice(i, 1); } const lastBuilding = buildings[buildings.length - 1]; if (!lastBuilding || lastBuilding.x + lastBuilding.width < gameCanvas.width + 100) { spawnBuilding(); } }
    function drawBuildings() { buildings.forEach(b => { ctx.fillStyle = b.color; ctx.fillRect(b.x, b.y, b.width, b.height); if (b.isVertiport) { const platformY = b.y - 15; ctx.fillStyle = '#455A64'; ctx.fillRect(b.x - 10, platformY, b.width + 20, 15); ctx.fillStyle = '#B0BEC5'; ctx.beginPath(); ctx.arc(b.x + b.width / 2, platformY + 7.5, b.width * 0.3, 0, Math.PI * 2); ctx.fill(); const lightColor = (Math.sin(b.wavePhase * 2) > 0) ? '#0ff' : '#ff0'; ctx.fillStyle = lightColor; ctx.fillRect(b.x, platformY + 5, 10, 5); ctx.fillRect(b.x + b.width - 10, platformY + 5, 10, 5); const waveWidth = b.width * 0.6; const waveX = b.x + (b.width - waveWidth) / 2; const waveSegmentHeight = 20; const numSegments = Math.ceil(platformY / waveSegmentHeight); for(let i=0; i<numSegments; i++) { const segmentY = platformY - (i + 1) * waveSegmentHeight; const alpha = 0.1 + Math.abs(Math.sin(b.wavePhase + i * 0.5)) * 0.2; const hue = 180 + Math.sin(b.wavePhase + i*0.3) * 20; ctx.fillStyle = `hsla(${hue}, 100%, 70%, ${alpha})`; ctx.fillRect(waveX, segmentY, waveWidth, waveSegmentHeight - 2); } } else { ctx.fillStyle = 'rgba(255, 255, 180, 0.2)'; for(let wy = b.y + 10; wy < b.y + b.height - 10; wy += 25) { for(let wx = b.x + 10; wx < b.x + b.width - 10; wx += 25) { if(Math.random() > 0.4) { ctx.fillRect(wx, wy, 10, 15); } } } } }); }
    function spawnPedestrian() { const type = Math.random() > 0.4 ? 'OldLady' : 'BalloonPerson'; pedestrians.push({ x: gameCanvas.width + 50 + Math.random() * 100, y: gameCanvas.height - SIDEWALK_HEIGHT + 5 + Math.random() * (SIDEWALK_HEIGHT - 20), type: type, size: type === 'OldLady' ? {w: 8, h: 16} : {w: 10, h: 18}, color: type === 'OldLady' ? 'pink' : `hsl(${Math.random()*360}, 60%, 70%)`, throwCooldown: 60 + Math.random() * 120, speed: currentScrollSpeed * PEDESTRIAN_SPEED_MULTIPLIER * (0.8 + Math.random() * 0.4), lastActionFrame: 0 }); }

    function updatePedestriansAndProjectiles() {
        const currentPedestrianSpawnChance = BASE_PEDESTRIAN_SPAWN_CHANCE * difficultyMultiplier;
        const currentProjectileThrowChance = BASE_PROJECTILE_THROW_CHANCE * difficultyMultiplier;
        for (let i = pedestrians.length - 1; i >= 0; i--) {
            const p = pedestrians[i]; p.x -= p.speed; p.throwCooldown = Math.max(0, p.throwCooldown - 1);
            if (p.throwCooldown === 0 && Math.random() < currentProjectileThrowChance) {
                if (p.type === 'OldLady') {
                    const itemType = Math.random() < 0.5 ? 'ChickenLeg' : 'CornCob';
                    let spawnY;
                    if (Math.random() < 0.2) { spawnY = gameCanvas.height * 0.1 + Math.random() * 20; } else { spawnY = gameCanvas.height * 0.5 + Math.random() * 50; }
                    let initialVy = -7 - Math.random() * 3; let initialVx = -1.0 - Math.random() * 1.0;
                    projectiles.push({ type: itemType, x: p.x, y: spawnY, vx: initialVx, vy: initialVy, size: {w: 4, h: (itemType === 'CornCob' ? 8 : 6)}, maxSize: 30 + Math.random() * 15, currentSize: 4, growthRate: 0.3 + Math.random() * 0.2, color: itemType === 'ChickenLeg' ? 'orange' : '#FFC107', rotation: 0, rotationSpeed: (Math.random() - 0.5) * 0.8, stuckFrames: 0, removeAfterFrames: -1 });
                } else {
                    const projectileBaseSpeedX = -currentScrollSpeed * PROJECTILE_SPEED_MULTIPLIER;
                    projectiles.push({ type: 'Balloon', x: p.x, y: p.y - 15, vx: projectileBaseSpeedX * (0.6 + Math.random() * 0.3), vy: -(1.5 + Math.random() * 1.8), size: {w: 12 + Math.random()*6, h: 16 + Math.random()*8}, color: `hsl(${Math.random()*360}, 80%, 70%)` });
                }
                p.throwCooldown = (80 + Math.random() * 130) / difficultyMultiplier; p.lastActionFrame = frameCount;
            }
            if (p.x + p.size.w < 0) { pedestrians.splice(i, 1); }
        }
        const maxPedestrians = 3 + Math.floor(difficultyMultiplier * 4);
        if (pedestrians.length < maxPedestrians && Math.random() < currentPedestrianSpawnChance) { spawnPedestrian(); }

        for (let i = projectiles.length - 1; i >= 0; i--) {
            const proj = projectiles[i]; proj.x += proj.vx; proj.y += proj.vy;
            if (proj.type === 'ChickenLeg' || proj.type === 'CornCob') {
                proj.vy += PROJECTILE_GRAVITY; proj.rotation += proj.rotationSpeed;
                if (proj.vy < 0 && proj.currentSize < proj.maxSize) { proj.currentSize += proj.growthRate; proj.size.w = proj.currentSize * (proj.type === 'CornCob' ? 0.6 : 1.0); proj.size.h = proj.currentSize * (proj.type === 'CornCob' ? 1.2 : 1.5); }
                const groundLevel = playableHeight - proj.size.h;
                if (proj.y >= groundLevel - 5) { if (Math.abs(proj.vy) < 0.5) { if (proj.stuckFrames !== undefined) { proj.stuckFrames++; }} else { proj.stuckFrames = 0; } if (proj.y >= groundLevel && proj.removeAfterFrames === -1) { proj.removeAfterFrames = 3; } proj.y = Math.min(proj.y, groundLevel); } else { proj.stuckFrames = 0; }
                if (proj.removeAfterFrames !== undefined && proj.removeAfterFrames > 0) { proj.removeAfterFrames--;}
                if ((proj.stuckFrames !== undefined && proj.stuckFrames > 50) || (proj.removeAfterFrames !== undefined && proj.removeAfterFrames === 0)) { projectiles.splice(i, 1); continue; }
            } else if (proj.type === 'Balloon') { proj.vx += (Math.random() - 0.5) * 0.1; proj.vx = Math.max(-1.2, Math.min(1.2, proj.vx)); }
            if (proj.x + proj.size.w < 0 || proj.y + proj.size.h < -50 || proj.y > gameCanvas.height + 50) { projectiles.splice(i, 1); }
        }
    }

    function drawPedestriansAndProjectiles() { pedestrians.forEach(p => { ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.size.w, p.size.h); const timeSinceAction = frameCount - p.lastActionFrame; const hintDuration = 30; if (p.lastActionFrame > 0 && timeSinceAction < hintDuration) { const alpha = 1 - (timeSinceAction / hintDuration); ctx.globalAlpha = alpha * 0.8; ctx.font = "12px 'Courier New', Courier, monospace"; ctx.textAlign = 'center'; if (p.type === 'OldLady') { ctx.fillStyle = 'orange'; ctx.fillText("üçó", p.x + p.size.w / 2, p.y - 5); } else { ctx.fillStyle = '#ccc'; ctx.fillText("o", p.x + p.size.w / 2, p.y - 5); } ctx.globalAlpha = 1.0; ctx.textAlign = 'left'; } }); projectiles.forEach(p => { ctx.save(); ctx.translate(p.x + p.size.w / 2, p.y + p.size.h / 2); if (p.type === 'ChickenLeg') { ctx.rotate(p.rotation); const meatWidth = p.size.w; const meatHeight = p.size.h * 0.65; const boneWidth = p.size.w * 0.25; const boneHeight = p.size.h * 0.4; const boneY = meatHeight / 2; ctx.fillStyle = '#D2691E'; ctx.beginPath(); ctx.ellipse(0, -meatHeight/4, meatWidth / 2, meatHeight / 2, 0, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#eee'; ctx.fillRect(-boneWidth / 2, boneY - boneHeight / 2, boneWidth, boneHeight); ctx.beginPath(); ctx.arc(-boneWidth / 2, boneY + boneHeight / 2, boneWidth * 0.4, 0, Math.PI * 2); ctx.arc(boneWidth / 2, boneY + boneHeight / 2, boneWidth * 0.4, 0, Math.PI * 2); ctx.fill(); } else if (p.type === 'CornCob') { ctx.rotate(p.rotation); const cobWidth = p.size.w; const cobHeight = p.size.h; const stickWidth = cobWidth * 0.3; const stickHeight = cobHeight * 0.3; const stickY = cobHeight * 0.35; ctx.fillStyle = '#FFC107'; ctx.beginPath(); ctx.ellipse(0, 0, cobWidth / 2, cobHeight / 2, 0, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = 'rgba(139, 69, 19, 0.5)'; ctx.lineWidth = Math.max(1, cobWidth * 0.05); for(let i = -cobWidth/2 + 3; i < cobWidth/2 - 3; i += cobWidth * 0.15) { ctx.beginPath(); ctx.moveTo(i, -cobHeight/2.5); ctx.lineTo(i + cobWidth*0.05, cobHeight/2.5); ctx.stroke(); ctx.beginPath(); ctx.moveTo(i+cobWidth*0.05, -cobHeight/2.5); ctx.lineTo(i, cobHeight/2.5); ctx.stroke(); } ctx.fillStyle = '#D2B48C'; ctx.fillRect(-stickWidth / 2, stickY, stickWidth, stickHeight); } else if (p.type === 'Balloon') { ctx.fillStyle = p.color; ctx.beginPath(); ctx.ellipse(0, 0, p.size.w / 2, p.size.h / 2, 0, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, p.size.h / 2); ctx.lineTo(0, p.size.h / 2 + 10); ctx.stroke(); } else { ctx.fillStyle = p.color; ctx.fillRect(-p.size.w / 2, -p.size.h / 2, p.size.w, p.size.h); } ctx.restore(); }); }
    function spawnBonus() { const isChargingTrigger = Math.random() < CHARGING_TRIGGER_SPAWN_CHANCE && !isChargingSequence; bonuses.push({ type: isChargingTrigger ? 'ChargingTrigger' : 'Battery', x: gameCanvas.width + 100 + Math.random() * 200, y: isChargingTrigger ? playableHeight * 0.1 + Math.random() * playableHeight * 0.3 : Math.random() * (playableHeight * 0.8), size: isChargingTrigger ? 30 : 20, speed: currentScrollSpeed * BONUS_SPEED_MULTIPLIER }); }
    function updateBonuses() { for (let i = bonuses.length - 1; i >= 0; i--) { const b = bonuses[i]; b.x -= b.speed; if (b.x + b.size < 0) bonuses.splice(i, 1); } const batteryCount = bonuses.filter(b => b.type === 'Battery').length; const triggerCount = bonuses.filter(b => b.type === 'ChargingTrigger').length; if (batteryCount < 3 && Math.random() < 0.005) spawnBonus(); if (triggerCount === 0 && Math.random() < CHARGING_TRIGGER_SPAWN_CHANCE) spawnBonus(); }
    function drawBonuses() { bonuses.forEach(b => { if (b.type === 'Battery') { ctx.fillStyle = '#4CAF50'; ctx.fillRect(b.x, b.y, b.size, b.size); ctx.fillStyle = 'white'; ctx.fillRect(b.x + b.size * 0.4, b.y + b.size * 0.2, b.size * 0.2, b.size * 0.6); ctx.fillRect(b.x + b.size * 0.2, b.y + b.size * 0.4, b.size * 0.6, b.size * 0.2); } else if (b.type === 'ChargingTrigger') { ctx.fillStyle = '#0ff'; ctx.beginPath(); ctx.arc(b.x + b.size / 2, b.y + b.size / 2, b.size / 2, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#ff0'; ctx.beginPath(); ctx.moveTo(b.x + b.size * 0.6, b.y + b.size * 0.2); ctx.lineTo(b.x + b.size * 0.4, b.y + b.size * 0.5); ctx.lineTo(b.x + b.size * 0.55, b.y + b.size * 0.5); ctx.lineTo(b.x + b.size * 0.35, b.y + b.size * 0.8); ctx.lineTo(b.x + b.size * 0.6, b.y + b.size * 0.45); ctx.lineTo(b.x + b.size * 0.45, b.y + b.size * 0.45); ctx.closePath(); ctx.fill(); } }); }
    function spawnBird() { const currentBirdSpawnChance = BASE_BIRD_SPAWN_CHANCE * difficultyMultiplier; if (birds.length < (4 + Math.floor(difficultyMultiplier * 6)) && Math.random() < currentBirdSpawnChance) { const isLarge = Math.random() < 0.3; const size = isLarge ? 25 + Math.random() * 10 : 12 + Math.random() * 8; const baseY = playableHeight * (isLarge ? 0.3 : 0.15) + Math.random() * playableHeight * (isLarge ? 0.4 : 0.7); let baseSpeed = currentScrollSpeed * BIRD_SPEED_MULTIPLIER * 1.1; let ampMultiplier = 1.2; let freqMultiplier = 1.2; if (score > 3000) { ampMultiplier = 1.5 + (difficultyMultiplier - 1.15) * 1.2; freqMultiplier = 1.5 + (difficultyMultiplier - 1.15) * 1.0; } birds.push({ x: gameCanvas.width + 50 + Math.random() * 100, y: baseY, baseY: baseY, size: size, type: isLarge ? 'large' : 'small', speed: baseSpeed * (isLarge ? (0.8 + Math.random() * 0.1) : (1.0 + Math.random() * 0.2)), color: `hsl(30, ${15+Math.random()*10}%, ${isLarge ? 40 : 60 + Math.random() * 20}%)`, wingPhase: Math.random() * Math.PI * 2, wingSpeed: (isLarge ? 0.15 : 0.25) + Math.random() * 0.08, wanderAmplitudeY: (25 + Math.random() * 50) * (isLarge ? 1.3 : 1.0) * ampMultiplier, wanderFrequencyY: (0.025 + Math.random() * 0.035) * (isLarge ? 0.8 : 1.0) * freqMultiplier, wanderPhaseOffsetY: Math.random() * Math.PI * 2, wanderAmplitudeX: (40 + Math.random() * 70) * (isLarge ? 0.8 : 1.0) * ampMultiplier, wanderFrequencyX: (0.02 + Math.random() * 0.025) * (isLarge ? 0.9 : 1.0) * freqMultiplier, wanderPhaseOffsetX: Math.random() * Math.PI * 2, baseXOffset: 0 }); } }
    function updateBirds() { const maxBirds = 4 + Math.floor(difficultyMultiplier * 6); for (let i = birds.length - 1; i >= 0; i--) { const bird = birds[i]; const timeFactorY = frameCount * bird.wanderFrequencyY + bird.wanderPhaseOffsetY; const timeFactorX = frameCount * bird.wanderFrequencyX + bird.wanderPhaseOffsetX; const offsetY = Math.sin(timeFactorY) * bird.wanderAmplitudeY; const offsetX = Math.cos(timeFactorX) * bird.wanderAmplitudeX; bird.baseXOffset -= bird.speed; bird.x = (gameCanvas.width + bird.baseXOffset) + offsetX; bird.y = bird.baseY + offsetY; bird.wingPhase += bird.wingSpeed; bird.y = Math.max(0, Math.min(bird.y, playableHeight - bird.size)); if (bird.x + bird.size < -150) { birds.splice(i, 1); }} spawnBird(); }
    function drawBirds() { birds.forEach(bird => { ctx.save(); ctx.translate(bird.x + bird.size / 2, bird.y + bird.size / 2); ctx.fillStyle = bird.color; ctx.beginPath(); ctx.ellipse(0, 0, bird.size * 0.4, bird.size * 0.25, 0, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(bird.size * 0.35, -bird.size * 0.1, bird.size * 0.15, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.moveTo(bird.size * 0.5, -bird.size * 0.1); ctx.lineTo(bird.size * 0.6, -bird.size * 0.15); ctx.lineTo(bird.size * 0.6, -bird.size * 0.05); ctx.closePath(); ctx.fill(); const wingY = Math.sin(bird.wingPhase) * (bird.size * 0.35); const wingAngle = Math.sin(bird.wingPhase) * 0.8; const wingLength = bird.size * 0.9; const wingWidth = bird.size * 0.4; ctx.save(); ctx.translate(-bird.size * 0.15, 0); ctx.rotate(-wingAngle); ctx.beginPath(); ctx.moveTo(0, 0); ctx.bezierCurveTo(-wingLength * 0.4, -wingY - wingWidth * 0.5, -wingLength * 0.8, -wingY - wingWidth * 0.2, -wingLength, -wingY + wingWidth * 0.1); ctx.bezierCurveTo(-wingLength * 0.9, -wingY + wingWidth * 0.5, -wingLength * 0.5, -wingY + wingWidth * 0.7, 0, 0); ctx.closePath(); ctx.fill(); ctx.restore(); ctx.save(); ctx.translate(bird.size * 0.15, 0); ctx.rotate(wingAngle); ctx.beginPath(); ctx.moveTo(0, 0); ctx.bezierCurveTo(wingLength * 0.4, -wingY - wingWidth * 0.5, wingLength * 0.8, -wingY - wingWidth * 0.2, wingLength, -wingY + wingWidth * 0.1); ctx.bezierCurveTo(wingLength * 0.9, -wingY + wingWidth * 0.5, wingLength * 0.5, -wingY + wingWidth * 0.7, 0, 0); ctx.closePath(); ctx.fill(); ctx.restore(); ctx.restore(); }); }
    
    // HOT Dawg logic starts here
    function spawnHotDawg() {
        const sizeW = 15;
        const sizeH = 40;
        hotDawgs.push({
            x: Math.random() * gameCanvas.width * 0.8,
            y: gameCanvas.height + sizeH,
            vx: (Math.random() - 0.5) * 2,
            vy: - (8 + Math.random() * 3), // Increased height
            size: { w: sizeW, h: sizeH },
            scale: 0.5,
            maxScale: 1.2,
            scaleRate: 0.005,
            fusePhase: 0,
            gravity: 0.05,
            wigglePhase: Math.random() * Math.PI * 2 // HOT Dawg wiggle added
        });
    }

    function updateHotDawgs() {
        for (let i = hotDawgs.length - 1; i >= 0; i--) {
            const dawg = hotDawgs[i];
            dawg.x += dawg.vx;
            dawg.y += dawg.vy;
            dawg.vy += dawg.gravity; // Arcing motion
            dawg.fusePhase += 0.5;
            
            // Wiggle logic
            dawg.wigglePhase += 0.15;
            dawg.x += Math.sin(dawg.wigglePhase) * 1.5;

            if (dawg.scale < dawg.maxScale) {
                dawg.scale += dawg.scaleRate;
            }
            if (dawg.y < -dawg.size.h) { // Remove if it goes off top of screen
                hotDawgs.splice(i, 1);
            }
        }
    }

    function drawHotDawgs() {
        hotDawgs.forEach(dawg => {
            ctx.save();
            ctx.translate(dawg.x, dawg.y);
            ctx.scale(dawg.scale, dawg.scale);

            // Bun
            ctx.fillStyle = '#D2B48C'; // tan
            ctx.beginPath();
            ctx.ellipse(-dawg.size.w * 0.25, 0, dawg.size.w * 0.25, dawg.size.h / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(dawg.size.w * 0.25, 0, dawg.size.w * 0.25, dawg.size.h / 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Sausage
            ctx.fillStyle = '#B22222'; // red
            ctx.beginPath();
            ctx.ellipse(0, 0, dawg.size.w * 0.3, dawg.size.h / 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Fuse
            const fuseY = dawg.size.h / 2;
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, fuseY);
            ctx.lineTo(0, fuseY + 8);
            ctx.stroke();

            // Spark
            const sparkSize = 2 + Math.sin(dawg.fusePhase) * 1.5;
            const sparkColor = (frameCount % 4 < 2) ? 'yellow' : 'white';
            ctx.fillStyle = sparkColor;
            ctx.shadowColor = 'orange';
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(0, fuseY + 8, sparkSize, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        });
    }

    function handleHotDawgCollision(dawg) {
        spawnExplosion(dawg.x, dawg.y);
        playExplosionSound();
        battery -= HOT_DAWG_BATTERY_COST;
        carY += 15; // dip
        triggerShake(30); // 0.5s shake
        updateBatteryUI();
    }

    function spawnExplosion(x, y) {
        explosions.push({ x, y, radius: 5, maxRadius: 40, life: 20 });
    }

    function updateExplosions() {
        for (let i = explosions.length - 1; i >= 0; i--) {
            const exp = explosions[i];
            exp.life--;
            exp.radius += (exp.maxRadius - exp.radius) * 0.2;
            if (exp.life <= 0) {
                explosions.splice(i, 1);
            }
        }
    }

    function drawExplosions() {
        explosions.forEach(exp => {
            ctx.save();
            const alpha = exp.life / 20;
            ctx.fillStyle = `rgba(255, 200, 0, ${alpha * 0.8})`;
            ctx.beginPath();
            ctx.arc(exp.x, exp.y, exp.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = `rgba(255, 100, 0, ${alpha * 0.6})`;
            ctx.beginPath();
            ctx.arc(exp.x, exp.y, exp.radius * 0.6, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        });
    }
    // HOT Dawg logic ends here

    function checkCollisions() {
        if (isChargingSequence || isCaptured) return;
        const carRect = { x: carX, y: carY, width: CAR_WIDTH, height: CAR_HEIGHT };
        buildings.forEach(b => { if (b.isVertiport) { const waveWidth = b.width * 0.6; const waveX = b.x + (b.width - waveWidth) / 2; const waveRect = { x: waveX, y: 0, width: waveWidth, height: b.y - 15 }; if (isColliding(carRect, waveRect)) { startCaptureSequence(b); return; } } if (b.x < carRect.x + carRect.width && b.x + b.width > carRect.x) { if (isColliding(carRect, { x: b.x, y: b.y, width: b.width, height: b.height })) { handleCollision(b); } } });
        if (isCaptured) return;
        for (let i = projectiles.length - 1; i >= 0; i--) { const p = projectiles[i]; if (isColliding(carRect, { x: p.x, y: p.y, width: p.size.w, height: p.size.h })) { handleCollision(p); projectiles.splice(i, 1); } }
        for (let i = birds.length - 1; i >= 0; i--) { const bird = birds[i]; const birdRect = { x: bird.x, y: bird.y, width: bird.size, height: bird.size }; if (isColliding(carRect, birdRect)) { handleCollision(bird); birds.splice(i, 1); } }
        for (let i = bonuses.length - 1; i >= 0; i--) { const b = bonuses[i]; if (isColliding(carRect, { x: b.x, y: b.y, width: b.size, height: b.size })) { if (b.type === 'ChargingTrigger') { startChargingSequence(b); } else { handleBonusPickup(b); } bonuses.splice(i, 1); break; } }
        for (let i = hotDawgs.length - 1; i >= 0; i--) { const dawg = hotDawgs[i]; const dawgRect = { x: dawg.x - dawg.size.w / 2, y: dawg.y - dawg.size.h / 2, width: dawg.size.w, height: dawg.size.h }; if (isColliding(carRect, dawgRect)) { handleHotDawgCollision(dawg); hotDawgs.splice(i, 1); } }

        blimps.forEach(blimp => {
            if (blimp.collidesWith(carRect)) {
                battery -= blimp.collisionDamage;
                triggerShake(20);
                playCollisionSound();
                playCollisionDissonance();
                updateBatteryUI();
            }
        });
    }
    function isColliding(rect1, rect2) { return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y; }
    function handleCollision(obstacle) { if (carShake < 2) { battery -= COLLISION_BATTERY_COST; triggerShake(10); playCollisionSound(); updateBatteryUI(); currentScrollSpeed = Math.min(MAX_SCROLL_SPEED, currentScrollSpeed + SCROLL_SPEED_INCREMENT); currentMusicTempo = Math.min(MAX_MUSIC_TEMPO, currentMusicTempo + MUSIC_TEMPO_INCREMENT); playCollisionDissonance(); } }
    function handleBonusPickup(bonus) { if (bonus.type === 'Battery') { battery = Math.min(100, battery + BONUS_BATTERY_GAIN); playBatteryPickupSound(); } else if (bonus.type === 'ChargingTrigger') { playBonusFlourish(); } if (bonus.type === 'Battery') score += 50; updateBatteryUI(); updateScoreUI(); }
    function drawGameBackground() { const gradient = ctx.createLinearGradient(0, 0, 0, playableHeight); gradient.addColorStop(0, '#1a2a3a'); gradient.addColorStop(0.7, '#334455'); gradient.addColorStop(1, '#445566'); ctx.fillStyle = gradient; ctx.fillRect(0, 0, gameCanvas.width, playableHeight); ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'; for(let i=0; i<60; i++) { let starX = (100 + i * 50 + frameCount * 0.15) % gameCanvas.width; let starY = (50 + i * 30) % playableHeight * 0.85; let size = 1 + Math.random() * 1.5; if (frameCount % (50 + i % 15) < 4) { ctx.fillRect(starX, starY, size*1.5, size*1.5); } else { ctx.fillRect(starX, starY, size, size); } } drawClouds(); drawSwarmBackground(); drawBuildings(); if (isChargingSequence && targetChargeStation) { ctx.fillStyle = '#444'; ctx.fillRect(targetChargeStation.x, targetChargeStation.y, targetChargeStation.width, 15); ctx.fillStyle = '#0ff'; ctx.fillRect(targetChargeStation.x + 5, targetChargeStation.y + 5, targetChargeStation.width - 10, 5); ctx.fillStyle = '#ff0'; ctx.fillRect(targetChargeStation.x + 15, targetChargeStation.y + 2, 10, 11); ctx.fillRect(targetChargeStation.x + targetChargeStation.width - 25, targetChargeStation.y + 2, 10, 11); } ctx.fillStyle = '#555'; ctx.fillRect(0, playableHeight, gameCanvas.width, SIDEWALK_HEIGHT); ctx.strokeStyle = '#888'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(0, playableHeight + 1); ctx.lineTo(gameCanvas.width, playableHeight + 1); ctx.stroke(); 
        if (surgeModeActive) {
            const pulse = Math.abs(Math.sin(frameCount * 0.05));
            const gradient = ctx.createRadialGradient(gameCanvas.width / 2, gameCanvas.height / 2, 0, gameCanvas.width / 2, gameCanvas.height / 2, gameCanvas.width / 2 + pulse * 100);
            gradient.addColorStop(0.7, 'rgba(0,0,0,0)');
            gradient.addColorStop(1, `rgba(0,0,0,${0.2 + pulse * 0.3})`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
        }
    }
    function drawCar() { let drawX = carX; let drawY = carY; if (carShake > 0) { drawX += (Math.random() - 0.5) * 8; drawY += (Math.random() - 0.5) * 8; carShake--; } const bodyWidth = CAR_WIDTH * 0.8; const bodyHeight = CAR_HEIGHT * 0.7; const bodyX = drawX + (CAR_WIDTH - bodyWidth) / 2; const bodyY = drawY + (CAR_HEIGHT - bodyHeight) / 2; const rotorSize = CAR_WIDTH * 0.3; const rotorOffsetY = bodyHeight * 0.3; ctx.fillStyle = carColor; ctx.fillRect(bodyX, bodyY, bodyWidth, bodyHeight); ctx.fillStyle = '#aaf'; ctx.fillRect(bodyX + bodyWidth * 0.5, bodyY + bodyHeight * 0.15, bodyWidth * 0.45, bodyHeight * 0.7); const rotorColor1 = '#ccc'; const rotorColor2 = '#999'; const rotorAnimSpeed = 0.3; const rotorColor = (Math.sin(frameCount * rotorAnimSpeed) > 0) ? rotorColor1 : rotorColor2; ctx.fillStyle = rotorColor; ctx.fillRect(drawX - rotorSize * 0.1, drawY - rotorOffsetY, rotorSize, rotorSize * 0.4); ctx.fillRect(drawX + CAR_WIDTH - rotorSize * 0.9, drawY - rotorOffsetY, rotorSize, rotorSize * 0.4); ctx.fillRect(drawX - rotorSize * 0.1, drawY + CAR_HEIGHT - rotorOffsetY, rotorSize, rotorSize * 0.4); ctx.fillRect(drawX + CAR_WIDTH - rotorSize * 0.9, drawY + CAR_HEIGHT - rotorOffsetY, rotorSize, rotorSize * 0.4); ctx.fillStyle = 'rgba(0, 255, 255, 0.2)'; ctx.fillRect(drawX, drawY + CAR_HEIGHT - 5, CAR_WIDTH, 5); }
    function spawnCloud() { const layer = Math.random(); const size = 60 + Math.random() * 120; clouds.push({ x: gameCanvas.width + size + Math.random() * 200, y: playableHeight * 0.05 + Math.random() * playableHeight * 0.5, size: size, opacity: 0.15 + layer * 0.3, speed: currentScrollSpeed * (0.2 + layer * 0.4), numPuffs: 3 + Math.floor(Math.random() * 3), puffOffsets: [] }); const cloud = clouds[clouds.length - 1]; for(let i = 0; i < cloud.numPuffs; i++) { cloud.puffOffsets.push({ x: (Math.random() - 0.5) * cloud.size * 0.7, y: (Math.random() - 0.5) * cloud.size * 0.25, radiusX: cloud.size * (0.25 + Math.random() * 0.2), radiusY: cloud.size * (0.15 + Math.random() * 0.15) }); } }
    function updateClouds() { for (let i = clouds.length - 1; i >= 0; i--) { const cloud = clouds[i]; cloud.x -= cloud.speed; if (cloud.x + cloud.size < 0) { clouds.splice(i, 1); } } if (clouds.length < 8 && Math.random() < 0.02) { spawnCloud(); } }
    function drawClouds() { clouds.forEach(cloud => { ctx.fillStyle = `rgba(200, 200, 220, ${cloud.opacity})`; cloud.puffOffsets.forEach(puff => { ctx.beginPath(); ctx.ellipse(cloud.x + puff.x, cloud.y + puff.y, puff.radiusX, puff.radiusY, 0, 0, Math.PI * 2); ctx.fill(); }); }); }
    function spawnSwarmVehicle() { const layer = Math.random(); const size = 5 + layer * 15; swarmVehicles.push({ x: Math.random() * gameCanvas.width, y: Math.random() * playableHeight * 0.9, sizeW: size * (1.5 + Math.random() * 0.5), sizeH: size, speed: currentScrollSpeed * (0.1 + layer * 0.3), color: `hsl(${180 + Math.random() * 60}, 70%, ${30 + layer * 40}%)`, bobPhase: Math.random() * Math.PI * 2, bobSpeed: 0.01 + Math.random() * 0.02, bobAmplitude: 2 + layer * 5 }); }
    function updateSwarmVehicles() { for (let i = swarmVehicles.length - 1; i >= 0; i--) { const v = swarmVehicles[i]; v.x -= v.speed; v.bobPhase += v.bobSpeed; v.y += Math.sin(v.bobPhase) * v.bobAmplitude * 0.1; if (v.x + v.sizeW < 0) { v.x = gameCanvas.width + v.sizeW + Math.random() * 100; v.y = Math.random() * playableHeight * 0.9; v.bobPhase = Math.random() * Math.PI * 2; } } if (swarmVehicles.length < 30 && Math.random() < 0.05) { spawnSwarmVehicle(); } }
    function drawSwarmBackground() { swarmVehicles.forEach(v => { ctx.fillStyle = v.color; const bodyY = v.y + Math.sin(v.bobPhase) * v.bobAmplitude; ctx.fillRect(v.x, bodyY, v.sizeW, v.sizeH * 0.6); ctx.fillRect(v.x - v.sizeW * 0.1, bodyY - v.sizeH * 0.2, v.sizeW * 0.3, v.sizeH * 0.3); ctx.fillRect(v.x + v.sizeW * 0.8, bodyY - v.sizeH * 0.2, v.sizeW * 0.3, v.sizeH * 0.3); ctx.fillStyle = `rgba(200, 220, 255, 0.1)`; ctx.fillRect(v.x - v.sizeW * 0.1, bodyY - v.sizeH * 0.1, v.sizeW * 1.2, v.sizeH * 0.8); }); }
    function findChargingStationSpot(triggerX) { let bestSpot = null; let maxGap = 0; for (let i = 0; i < buildings.length - 1; i++) { const b1 = buildings[i]; const b2 = buildings[i+1]; const gapStart = b1.x + b1.width; const gapEnd = b2.x; const gapWidth = gapEnd - gapStart; if (gapWidth > CAR_WIDTH + 40 && gapStart < triggerX + 100 && gapEnd > triggerX - 100) { if (gapWidth > maxGap) { maxGap = gapWidth; bestSpot = { x: gapStart + (gapWidth / 2) - 40, y: playableHeight - 10, width: 80 }; } } } if (!bestSpot) { bestSpot = { x: carX, y: gameCanvas.height + 50, width: 80 }; console.warn("No suitable gap found!"); } return bestSpot; }

    function startChargingSequence(trigger) {
        if (isChargingSequence || isCaptured) return;
        isChargingSequence = true; chargingPhase = 'descending'; playerControlEnabled = false; targetChargeStation = findChargingStationSpot(trigger.x); autoPilotStartY = carY; autoPilotProgress = 0;
        stopEngineHum(); playPullDownSound();
        if (musicGainNode) musicGainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
        stopBackgroundMusic();
    }
    function updateChargingSequence() {
        const descentSpeed = 0.015; const blastOffSpeed = 0.05;
        if (chargingPhase === 'descending') {
            autoPilotProgress = Math.min(1, autoPilotProgress + descentSpeed); const easedProgress = 0.5 * (1 - Math.cos(autoPilotProgress * Math.PI)); carY = autoPilotStartY + (targetChargeStation.y - CAR_HEIGHT / 2 - autoPilotStartY) * easedProgress; carX += (targetChargeStation.x + targetChargeStation.width/2 - CAR_WIDTH/2 - carX) * 0.05;
            if (autoPilotProgress >= 1) { chargingPhase = 'charging'; carColor = '#0f0'; playChargingSound(); chargeStartTime = performance.now(); }
        } else if (chargingPhase === 'charging') {
            const elapsed = performance.now() - chargeStartTime; const chargeProgress = Math.min(1, elapsed / CHARGE_DURATION_MS); battery = Math.min(100, Math.floor(chargeProgress * 100)); updateBatteryUI();
            if (chargeProgress >= 1) { chargingPhase = 'blastoff'; carColor = 'white'; stopChargingSound(); playChargeCompleteSound(); playLaunchSound(); autoPilotStartY = carY; autoPilotProgress = 0; }
        } else if (chargingPhase === 'blastoff') {
            autoPilotProgress = Math.min(1, autoPilotProgress + blastOffSpeed); const targetY = playableHeight / 2; const easedProgress = 0.5 * (1 - Math.cos(autoPilotProgress * Math.PI)); carY = autoPilotStartY + (targetY - autoPilotStartY) * easedProgress;
            if (autoPilotProgress >= 1) {
                 isChargingSequence = false; chargingPhase = null; playerControlEnabled = true; targetChargeStation = null;
                 playEngineHum();
                 if (musicGainNode) musicGainNode.gain.linearRampToValueAtTime(0.45, audioCtx.currentTime + 0.5);
                 if (gameRunning && !musicIsPlaying) { startMusicLoopChecker(); }
            }
        }
    }
    function startCaptureSequence(building) {
        if (isCaptured || isChargingSequence) return;
        isCaptured = true; capturePhase = 'descending'; playerControlEnabled = false; captureTargetBuilding = building; autoPilotStartY = carY; autoPilotProgress = 0;
        stopEngineHum();
        playLockOnSound();
        playVertiportRefuelSound();
        playVertiportPowerDownSound();
        stopBackgroundMusic();
        if (musicGainNode) musicGainNode.gain.linearRampToValueAtTime(0.1, audioCtx.currentTime + 0.5);
    }
    function updateCaptureSequence() {
        const descentSpeed = 0.01; const releaseSpeed = 0.04; const targetY = captureTargetBuilding.y - CAR_HEIGHT * 0.8;
        if (capturePhase === 'descending') {
            autoPilotProgress = Math.min(1, autoPilotProgress + descentSpeed); const easedProgress = 0.5 * (1 - Math.cos(autoPilotProgress * Math.PI)); carY = autoPilotStartY + (targetY - autoPilotStartY) * easedProgress; const targetX = captureTargetBuilding.x + captureTargetBuilding.width / 2 - CAR_WIDTH / 2; carX += (targetX - carX) * 0.03;
            if (autoPilotProgress >= 1) {
                capturePhase = 'holding';
                captureStartTime = performance.now();
            }
        } else if (capturePhase === 'holding') {
            const elapsed = performance.now() - captureStartTime; const drainProgress = Math.min(1, elapsed / CAPTURE_HOLD_DURATION_MS); battery = Math.max(0, 100 - Math.floor(drainProgress * CAPTURE_BATTERY_DRAIN)); updateBatteryUI(); if (frameCount % 30 === 0) playCaptureHoldingPulse();
            if (elapsed >= CAPTURE_HOLD_DURATION_MS) { capturePhase = 'releasing'; playCaptureReleaseChime(); autoPilotStartY = carY; autoPilotProgress = 0; }
        } else if (capturePhase === 'releasing') {
            autoPilotProgress = Math.min(1, autoPilotProgress + releaseSpeed); const targetReleaseY = playableHeight / 2; const easedProgress = autoPilotProgress * autoPilotProgress; carY = autoPilotStartY + (targetReleaseY - autoPilotStartY) * easedProgress;
            if (autoPilotProgress >= 1) {
                 isCaptured = false; capturePhase = null; playerControlEnabled = true; captureTargetBuilding = null;
                 playEngineHum();
                 if (musicGainNode) musicGainNode.gain.linearRampToValueAtTime(0.45, audioCtx.currentTime + 0.5);
                 if (gameRunning && !musicIsPlaying) { startMusicLoopChecker(); }
            }
        }
    }

    function spawnBlimp(options = {}) {
        let speedMultiplier = 1.0;
        if (score >= 14200) {
            speedMultiplier = 1.5;
        }
        blimps.push(new Blimp(gameCanvas, playableHeight, blimpLogoImage, options, speedMultiplier));
        if (!blimpThemeIsPlaying) {
            playBlimpTheme();
        }
    }

    function updateGameState() {
       if (playerControlEnabled) {
           let vertDelta = 0; let horzDelta = 0;
           if ((keys['ArrowUp'] || keys['w']) && !(prevKeys['ArrowUp'] || prevKeys['w'])) { playDodgeSound(-1); }
           if ((keys['ArrowDown'] || keys['s']) && !(prevKeys['ArrowDown'] || prevKeys['s'])) { playDodgeSound(1); }
           if (keys['ArrowUp'] || keys['w']) vertDelta = -MOVE_SPEED_Y;
           if (keys['ArrowDown'] || keys['s']) vertDelta = MOVE_SPEED_Y;
           if (keys['ArrowLeft'] || keys['a']) horzDelta = -MOVE_SPEED_X;
           if (keys['ArrowRight'] || keys['d']) horzDelta = MOVE_SPEED_X;
           carY += vertDelta; carY = Math.max(0, Math.min(carY, playableHeight - CAR_HEIGHT));
           carX += horzDelta; carX = Math.max(MIN_CAR_X, Math.min(carX, MAX_CAR_X));
           modulateEngineHum(battery, vertDelta, horzDelta);
       }
       updateBuildings(); updatePedestriansAndProjectiles(); updateBonuses(); updateBirds(); updateClouds(); updateSwarmVehicles(); updateHotDawgs(); updateExplosions();

       for (let i = blimps.length - 1; i >= 0; i--) {
            const blimp = blimps[i];
            blimp.update();
            if (blimp.x + blimp.width + 240 + 20 < 0) {
                blimps.splice(i, 1);
                if (blimps.length === 0) {
                    stopBlimpTheme();
                }
            }
        }

       if (playerControlEnabled) checkCollisions();

       if (playerControlEnabled) {
           battery -= BATTERY_DRAIN_RATE; score++;

            let baseDifficultyMultiplier = 1.0;
            if (score < 1000) { baseDifficultyMultiplier = 0.5;
            } else if (score < 2000) { baseDifficultyMultiplier = 1.0;
            } else if (score < 3000) { baseDifficultyMultiplier = 1.2;
            } else if (score < 4000) { baseDifficultyMultiplier = 1.4;
            } else { baseDifficultyMultiplier = 1.6; }
            difficultyMultiplier = baseDifficultyMultiplier;

            if (score > 13000) {
                const chaosFactor = Math.min(2.5, 1.0 + (score - 13000) * 0.00005);
                difficultyMultiplier *= chaosFactor;
            }

            const difficultyProgress = Math.min(1, Math.max(0, (score - 1000) / 8000));

            currentScrollSpeed = BASE_SCROLL_SPEED + (MAX_SCROLL_SPEED - BASE_SCROLL_SPEED) * difficultyProgress * difficultyMultiplier;
            currentMusicTempo = BASE_MUSIC_TEMPO + (MAX_MUSIC_TEMPO - BASE_MUSIC_TEMPO) * difficultyProgress * difficultyMultiplier;

            const speedCapMultiplier = (score > 13000 ? 1.8 : 1.2);
            currentScrollSpeed = Math.min(MAX_SCROLL_SPEED * speedCapMultiplier , currentScrollSpeed);
            currentMusicTempo = Math.min(MAX_MUSIC_TEMPO * speedCapMultiplier, currentMusicTempo);
       }

        if (gameRunning && playerControlEnabled && blimps.length === 0) {
            // Double Blimp spawn logic
            if (score >= 14400 && !doubleBlimpsTriggered) {
                spawnBlimp({ offsetX: 0, offsetY: 0, large: false });
                spawnBlimp({ offsetX: 240, offsetY: 150, large: true });
                doubleBlimpsTriggered = true;
            } else if (score >= nextBlimpScoreTarget) {
                spawnBlimp();
                nextBlimpScoreTarget = score + BLIMP_SCORE_INTERVAL_MIN + Math.random() * (BLIMP_SCORE_INTERVAL_MAX - BLIMP_SCORE_INTERVAL_MIN);
            }
        }

        if (score >= 14000 && Math.random() < HOT_DAWG_SPAWN_CHANCE) {
            spawnHotDawg();
        }

        if (score >= 15000 && !surgeModeTriggered) {
            surgeModeActive = true;
            surgeModeTriggered = true;
            playSurgeSound();
        }

       if (playerControlEnabled && battery <= 0) gameOver();
    }

    function gameLoop() {
        if (!gameRunning) return;
        frameCount++;
        if (isChargingSequence) { updateChargingSequence(); updateBuildings(); updateClouds(); updateSwarmVehicles(); }
        else if (isCaptured)    { updateCaptureSequence(); updateBuildings(); updateClouds(); updateSwarmVehicles(); }
        else                    { updateGameState(); }

        ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
        drawGameBackground();
        blimps.forEach(b => b.draw(ctx));
        drawPedestriansAndProjectiles();
        drawBonuses();
        drawBirds();
        drawHotDawgs();
        drawExplosions();
        drawCar();
        updateBatteryUI(); updateScoreUI();
        prevCarX = carX; prevCarY = carY; prevKeys = { ...keys };
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    function startGame() {
        gameRunning = false;
        if (animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId = null;
        stopAllSounds();

        battery = 100; score = 0; calculateDimensions(); carY = playableHeight / 2; carX = 80; carColor = 'white'; keys = {}; prevKeys = {}; buildings = []; pedestrians = []; projectiles = []; bonuses = []; birds = []; clouds = []; swarmVehicles = []; carShake = 0; frameCount = 0; lowBatteryWarningPlayed = false; isChargingSequence = false; chargingPhase = null; targetChargeStation = null; isCaptured = false; capturePhase = null; captureTargetBuilding = null; playerControlEnabled = true; prevCarX = carX; prevCarY = carY;
        hotDawgs = []; explosions = [];
        spawnBuilding(gameCanvas.width * 0.6); spawnBuilding(); for(let i=0; i<5; i++) spawnCloud(); for(let i=0; i<20; i++) spawnSwarmVehicle();
        currentScrollSpeed = BASE_SCROLL_SPEED; currentMusicTempo = BASE_MUSIC_TEMPO;
        difficultyMultiplier = 1.0;

        blimps = [];
        nextBlimpScoreTarget = 10000;
        blimpThemeIsPlaying = false;
        blimpThemeNextPlayTime = 0; 
        doubleBlimpsTriggered = false;
        surgeModeActive = false;
        surgeModeTriggered = false;

        startScreen.style.display = 'none';
        gameCanvas.style.display = 'block';
        uiOverlay.style.display = 'block';
        brandingWatermark.style.display = 'block';
        gameOverScreen.style.display = 'none';
        updateBatteryUI(); updateScoreUI();

        const isMobileDevice = window.matchMedia('(pointer: coarse)').matches;
        if (isMobileDevice) {
            if (mobileControlsLeft) mobileControlsLeft.style.display = 'block';
            if (mobileControlsRight) mobileControlsRight.style.display = 'flex';
        } else {
             if (mobileControlsLeft) mobileControlsLeft.style.display = 'none';
            if (mobileControlsRight) mobileControlsRight.style.display = 'none';
        }

        setTimeout(() => {
             if (!audioInitialized) {
                console.warn("startGame: Audio not initialized. Will attempt init via initAudio().");
                if (!initAudio()) {
                    console.error("startGame: Audio initialization failed during game start sequence. Music/sounds may not play.");
                }
             }

             if (audioInitialized && audioCtx && audioCtx.state === 'running') {
                 console.log("startGame: Audio ready, playing sounds/music.");
                 playStartJingle(); playEngineHum();
                 if (musicGainNode) musicGainNode.gain.setValueAtTime(0.45, audioCtx.currentTime);
                 if (musicLowPassFilter) musicLowPassFilter.frequency.setValueAtTime(20000, audioCtx.currentTime);
                 startMusicLoopChecker();
             } else {
                 console.warn(`startGame: Audio not fully ready after timeout (State: ${audioCtx?.state}, Initialized: ${audioInitialized}). Music might not start.`);
             }
             gameRunning = true;
             if (animationFrameId) cancelAnimationFrame(animationFrameId);
             animationFrameId = requestAnimationFrame(gameLoop);
             console.log("Game started. GameRunning:", gameRunning);
        }, 50);
    }

    function gameOver() {
      if (!gameRunning) return;
      gameRunning = false; playerControlEnabled = false;
      stopAllSounds();
      if (animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId = null;

      uiOverlay.style.display = 'none';
      brandingWatermark.style.display = 'none';
      if (mobileControlsLeft) mobileControlsLeft.style.display = 'none';
      if (mobileControlsRight) mobileControlsRight.style.display = 'none';

      finalScoreLabel.textContent = `Final Score: ${score}`;
      gameOverScreen.style.display = 'flex';
      if (audioInitialized && audioCtx && audioCtx.state === 'running') { playGameOverFanfare(); }
    }

    function handleStartOrReplay(event) {
        event.preventDefault();
        const buttonId = event.target.id;
        console.log(`${buttonId} Clicked. AudioContext state: ${audioCtx?.state}`);
        if (!audioCtx) { console.error("Cannot start game, AudioContext creation failed."); return; }

        if (buttonId === 'startButton' && gameRunning) {
            console.warn("Start button clicked, but game is already running.");
            return;
        }

        const attemptStartGame = () => {
            if (initAudio() || (audioCtx.state === 'running' && audioInitialized)) {
                console.log(`${buttonId}: Audio ready, starting game.`);
                startGame();
            } else {
                console.error(`${buttonId}: Failed to initialize audio nodes or context not running. State: ${audioCtx?.state}, Initialized: ${audioInitialized}`);
                alert("Audio system failed to initialize. Please try again, or refresh if the problem persists.");
            }
        };

        if (audioCtx.state === 'suspended') {
            console.log("AudioContext suspended, resuming...");
            audioCtx.resume().then(() => {
                 console.log(`AudioContext state after resume attempt: ${audioCtx.state}`);
                 if (audioCtx.state === 'running') {
                     attemptStartGame();
                 } else {
                     console.error(`${buttonId}: AudioContext did not resume to 'running' state.`);
                     alert("Could not enable audio. Please tap the screen or button again.");
                 }
            }).catch(err => {
                console.error("AudioContext resume failed:", err);
                alert(`Audio could not be started: ${err.name}.`);
            });
        } else if (audioCtx.state === 'running') {
             console.log("AudioContext already running.");
            attemptStartGame();
        } else {
             console.error(`AudioContext in unexpected state: ${audioCtx.state}. Cannot start.`);
             alert(`Audio system error (State: ${audioCtx.state}). Please reload.`);
        }
    }
    startButton.addEventListener('click', handleStartOrReplay);
    replayButton.addEventListener('click', handleStartOrReplay);

    window.addEventListener('keydown', (e) => {
        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 's', 'a', 'd', ' '].includes(e.key)) {
            e.preventDefault(); // Prevent scrolling for game keys
        }
        keys[e.key] = true;

        if ((e.key === 'Enter' || e.key === 'Return') && startScreen.style.display === 'flex' && !gameRunning) {
            e.preventDefault();
            startButton.click();
        }
        if ((e.key === 'Enter' || e.key === 'Return') && gameOverScreen.style.display === 'flex' && !gameRunning) {
            e.preventDefault();
            replayButton.click();
        }
    });
    window.addEventListener('keyup', (e) => { keys[e.key] = false; });

    function handleTouchStart(key, event) { event.preventDefault(); keys[key] = true; }
    function handleTouchEnd(key, event) { event.preventDefault(); keys[key] = false; }
    touchUpButton.addEventListener('touchstart', (e) => handleTouchStart('ArrowUp', e), { passive: false });
    touchUpButton.addEventListener('touchend', (e) => handleTouchEnd('ArrowUp', e));
    touchDownButton.addEventListener('touchstart', (e) => handleTouchStart('ArrowDown', e), { passive: false });
    touchDownButton.addEventListener('touchend', (e) => handleTouchEnd('ArrowDown', e));
    touchLeftButton.addEventListener('touchstart', (e) => handleTouchStart('ArrowLeft', e), { passive: false });
    touchLeftButton.addEventListener('touchend', (e) => handleTouchEnd('ArrowLeft', e));
    touchRightButton.addEventListener('touchstart', (e) => handleTouchStart('ArrowRight', e), { passive: false });
    touchRightButton.addEventListener('touchend', (e) => handleTouchEnd('ArrowRight', e));
    [touchUpButton, touchDownButton, touchLeftButton, touchRightButton, startButton, replayButton].forEach(button => {
        button.addEventListener('contextmenu', (e) => e.preventDefault());
    });

    function resizeGame() {
        const width = window.innerWidth; const height = window.innerHeight;
        gameCanvas.width = width; gameCanvas.height = height;
        gameCanvas.style.width = width + 'px'; gameCanvas.style.height = height + 'px';
        calculateDimensions(); updateBatteryUI(); updateScoreUI();
        if (!gameRunning && ctx) {
            ctx.fillStyle = '#050510'; ctx.fillRect(0,0, width, height);
            if (swarmVehicles?.length) { drawSwarmBackground(); }
        }
        if (gameRunning && playerControlEnabled) {
            carX = Math.max(MIN_CAR_X, Math.min(carX, MAX_CAR_X));
            carY = Math.max(0, Math.min(carY, playableHeight - CAR_HEIGHT));
        }
    }
    let resizeTimeout;
    window.addEventListener('resize', () => { clearTimeout(resizeTimeout); resizeTimeout = setTimeout(resizeGame, 100); });
    window.addEventListener('orientationchange', () => { clearTimeout(resizeTimeout); resizeTimeout = setTimeout(resizeGame, 150); });

    document.addEventListener('visibilitychange', () => {
        if (!audioCtx) return;

        if (document.hidden) {
            console.log("Main visibilitychange: Page hidden.");
            if (musicIsPlaying) {
                stopBackgroundMusic();
            }
            if (blimpThemeIsPlaying) { // If blimp theme system was active
                stopBlimpTheme(true); // Stop it immediately
            }
        } else {
            console.log("Main visibilitychange: Page visible. Attempting auto-resume.");
            if (audioCtx.state === "suspended") {
                audioCtx.resume().then(() => {
                    console.log(`Main visibilitychange: AudioContext auto-resumed. New state: ${audioCtx.state}`);
                    if (!audioInitialized) {
                        console.log("Main visibilitychange: Attempting audio re-initialization after auto-resume.");
                        initAudio();
                    }
                    if (audioCtx.state === 'running' && audioInitialized && gameRunning && !musicIsPlaying && !isChargingSequence && !isCaptured) {
                        console.log("Main visibilitychange: Restarting background music loop (context was suspended).");
                        startMusicLoopChecker();
                    }
                    if (blimps.length > 0 && audioCtx.state === 'running' && audioInitialized && gameRunning) {
                        console.log("Main visibilitychange: Page visible, blimp exists. Re-evaluating blimp theme.");
                        blimpThemeIsPlaying = true;
                        playBlimpTheme();
                    }
                }).catch(err => {
                    console.error("Main visibilitychange: Error during AudioContext auto-resume:", err);
                });
            } else if (audioCtx.state === "running") {
                if (!audioInitialized) { initAudio(); }
                if (audioInitialized && gameRunning && !musicIsPlaying && !isChargingSequence && !isCaptured) {
                    console.log("Main visibilitychange: Restarting background music loop (context already running).");
                    startMusicLoopChecker();
                }
                 if (blimps.length > 0 && audioInitialized && gameRunning) {
                     console.log("Main visibilitychange: Page visible, blimp exists, context running. Re-evaluating blimp theme.");
                     blimpThemeIsPlaying = true;
                     playBlimpTheme();
                }
            }
        }
    });

    document.addEventListener('DOMContentLoaded', () => {
        resizeGame(); updateBatteryUI(); updateScoreUI();
        for(let i=0; i<20; i++) spawnSwarmVehicle();
        let initialSwarmLoopId = null;
        function initialSwarmLoop() {
            if (gameRunning) { if (initialSwarmLoopId) cancelAnimationFrame(initialSwarmLoopId); initialSwarmLoopId = null; return; }
            if (ctx && gameCanvas.width > 0 && gameCanvas.height > 0) {
                ctx.fillStyle = '#050510'; ctx.fillRect(0,0, gameCanvas.width, gameCanvas.height);
                updateSwarmVehicles(); drawSwarmBackground();
                initialSwarmLoopId = requestAnimationFrame(initialSwarmLoop);
            }
        }
        requestAnimationFrame(() => {
           if (gameCanvas.width === 0 || gameCanvas.height === 0) { resizeGame(); }
           if (gameCanvas.width > 0 && gameCanvas.height > 0) { initialSwarmLoop(); }
        });
        startScreen.style.display = 'flex';
    });
</script>

</body>
</html>
